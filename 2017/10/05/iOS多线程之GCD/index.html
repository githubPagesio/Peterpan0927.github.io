<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS多线程之GCD | Peterpan&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="了解到了消息循环之后，接下来就要学习iOS中最常使用的多线程使用方式了—GCD">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS多线程之GCD">
<meta property="og:url" content="http://yoursite.com/2017/10/05/iOS多线程之GCD/index.html">
<meta property="og:site_name" content="Peterpan's Blog">
<meta property="og:description" content="了解到了消息循环之后，接下来就要学习iOS中最常使用的多线程使用方式了—GCD">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8A%E5%8D%8810.56.23.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8A%E5%8D%8811.29.49.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%882.40.51.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%882.46.24.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/7DA841E463C1B07B74B06F79BE0D16C2.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%885.15.15.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%886.03.41.png">
<meta property="og:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-06%20%E4%B8%8A%E5%8D%8812.39.36.png">
<meta property="og:updated_time" content="2018-03-13T16:00:22.786Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS多线程之GCD">
<meta name="twitter:description" content="了解到了消息循环之后，接下来就要学习iOS中最常使用的多线程使用方式了—GCD">
<meta name="twitter:image" content="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8A%E5%8D%8810.56.23.png">
  
    <link rel="alternate" href="/atom.xml" title="Peterpan&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/p1.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%8811.42.23.png">
    <h2 class="author">Peter pan</h2>
    <h3 class="description">the mark of an educated mind is to be able to entertain a thought without accepting it</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>86</strong><br>文章</div></a>
      <a href="/categories"><div><strong>80</strong><br>分类</div></a>
      <a href="/tags"><div><strong>14</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-iOS多线程之GCD" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/05/iOS多线程之GCD/" class="article-date">
  <time class="post-time" datetime="2017-10-05T10:09:12.000Z" itemprop="datePublished">
    <span class="post-month">10月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS多线程之GCD
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/串-并行队列-GCD实现单例/">串/并行队列 GCD实现单例</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>了解到了消息循环之后，接下来就要学习iOS中最常使用的多线程使用方式了—GCD</p>
<a id="more"></a>
<h1 id="iOS多线程之GCD"><a href="#iOS多线程之GCD" class="headerlink" title="iOS多线程之GCD"></a>iOS多线程之GCD</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>GCD的全称是Grand Central Dispatch,纯C语言，提供了非常强大的函数，会自动的利用更多的CPU内核</p>
<pre><code class="objective-c">//GCD基本演示
- (void)demo{
      //创建任务
      dispatch_block_t = ^{
      NSLpg(@&quot;task&quot;, [NSThread currentThread]);
    };
      //获取队列
      dispatch_queue_t queue = dispathch_get_global_queue(0, 0);
      //把任务放进队列
      dispatch_async(queue, task);
}
//但是一般正常的用法是这样的：
dispatch_async(dispatch_get_global_queue(0,0), ^{
   //代码部分
   NSLog(@&quot;hello world&quot;);
});
</code></pre>
<p>接下来就要说一下GCD和NSThread不同的地方，在NSThread中，需要自己去管理线程的生命周期（开启，睡眠，死亡等），线程同步对于数据的加锁操作会有一定的系统资源开销，而在GCD中，开发者可以不需要直接的去操作线程，而是将所要执行的任务封装成一个unit丢给线程池去处理，线程池会有效的管理线程的并发和生死。可以近似的类比成从MRC到ARC的过程中，内存由程序员手动释放到自动释放的过程。</p>
<h2 id="GCD改写"><a href="#GCD改写" class="headerlink" title="GCD改写"></a>GCD改写</h2><p>之前我们写了一个使用NSThread异步下载图片的例子，现在我们可以使用GCD来改写一下这个程序：</p>
<pre><code class="objective-c"> dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSURL *url = [NSURL URLWithString:@&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3751777155,630098310&amp;fm=27&amp;gp=0.jpg&quot;];
        NSData *data = [NSData dataWithContentsOfURL:url];
        UIImage *image = [UIImage imageWithData:data];
        //线程间通信 子--&gt;主
        dispatch_async(dispatch_get_main_queue(), ^{
            self.testImageView.image = image;
            //根据图片的大小来调整位置
            [self.testImageView sizeToFit];
            [self.scrollView setContentSize:image.size];
        });
    });
</code></pre>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>之前在NSThread中提到了同步和异步的概念，在GCD中有任务和队列的概念 ，通过串行和并行来描述任务执行的方式,同步和异步决定了要不要开启新的线程。</p>
<pre><code class="objective-c">//串行队列，同步执行
dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;,  DISPATCH_QUEUE_SERIAL);
//同步执行
dispatch_sync(serialQueue, ^{
        NSLog(@&quot;%@&quot;, [NSThread currentThread]);
    });
</code></pre>
<pre><code class="objective-c">//并行队列，异步执行
dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);
//异步执行
dispatch_async(concurrentQueue, ^{
        NSLog(@&quot;%@&quot;, [NSThread currentThread]);
    });
</code></pre>
<p>这个时候我们可以注意到并行队列异步执行其实是开了多个线程无序的执行，这个时候是效率最大的。如果是并行队列，同步执行的话会有什么样的后果呢？尝试了一下之后发现如果设置为同步执行的话和不开线程的效果一样,任务顺序执行，等于串行队列同步执行。</p>
<h4 id="主队列"><a href="#主队列" class="headerlink" title="主队列"></a>主队列</h4><pre><code class="objective-c">//得到主队列
dispatch_queue_t mainQueue = dispatch_get_main_queue();
//异步执行
for(int = 1 ; i &lt; 100 ; ++i ){
    dispatch_async(mainQueue, ^{
        NSLog(@&quot;main queue %@&quot;, [NSThread currentThread]);
    });    
}
</code></pre>
<p> 这样的话所有的任务都会在主线程上执行，打印出来是这样的效果：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8A%E5%8D%8810.56.23.png" alt=""></p>
<p>但是如果是同步执行的话，再去打印主队列所在的线程信息，会发现线程会卡在那里，这里展示一张图：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8A%E5%8D%8811.29.49.png" alt=""></p>
<p>因为线程是同步执行的，这个时候主线程执行这个主队列的任务，但是主队列又要放到主线程中去执行，主线程是一个特殊的串行队列，所以要等大框执行完了才会执行小框的任务，所以就造成了在一个循环中不停的相互等待,导致线程死锁。这种情况下死锁是因为在主线程下，往主队列中添加任务同步执行产生的。</p>
<h4 id="全局并发队列"><a href="#全局并发队列" class="headerlink" title="全局并发队列"></a>全局并发队列</h4><p>全局并发队列我们可以通过下面这种方式来得到：</p>
<pre><code class="objective-c">/*
    现在来解释一下中间这两个参数的意义
    1.qos_class_t(iOS8之后)，dispatch_queue_priority_t(iOS8之前)
    第一个参数是为了表示优先级，填0是为了适配两个不同的版本
    2.flags 没什么用，给未来使用，填0即可
*/
dispatch_queue_t queue = dispatch_queue_global_queue(0,0);
</code></pre>
<p>最后放一张关系图来供参考所用：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%882.40.51.png" alt=""></p>
<p>另外关于串行，并行和同步异步之间的关系还可以参考<a href="https://liufubo1991.github.io/2017/07/13/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E4%B8%8E%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%E4%B8%8E%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="external">博客</a></p>
<h2 id="关于GCD的一些Demo演练"><a href="#关于GCD的一些Demo演练" class="headerlink" title="关于GCD的一些Demo演练"></a>关于GCD的一些Demo演练</h2><p>学习了关于GCD的一些基本用法之后，我们也需要来进行一些demo的演练来满足我们的日常需求：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%882.46.24.png" alt=""></p>
<pre><code class="objective-c">//首先分析1，2在子线程顺序执行，所以是异步串行队列
- (void)demo{
    //创建串行队列
    dispatch_queue_t serialQueue = dispatch_queue_create(&quot;serialQueue&quot;, DISPATCH_QUEUE_SERIAL);
    dispatch_async(serialQueue, ^{
        NSLog(@&quot;任务1 %@&quot;, [NSThread currentThread]);
    });
    dispatch_async(serialQueue, ^{
        NSLog(@&quot;任务2 %@&quot;, [NSThread currentThread]);
    });
    //完成之后通知主线程执行3，4
    dispatch_sync(serialQueue, ^{
        dispatch_async(dispatch_get_main_queue(),^{
            NSLog(@&quot;任务3 %@&quot;, [NSThread currentThread]);
        });
        dispatch_async(dispatch_get_main_queue(),^{
            NSLog(@&quot;任务4 %@&quot;, [NSThread currentThread]);
        });
    });
    //完成之后再并发执行任务5，6，7，这个时候就需要用到全局并发队列，要先获取到主队列
    dispatch_async(dispatch_get_main_queue(), ^{
       dispatch_async(dispatch_get_global_queue(0, 0), ^{
           NSLog(@&quot;任务5 %@&quot;, [NSThread currentThread]);
       });
       dispatch_async(dispatch_get_global_queue(0, 0), ^{
           NSLog(@&quot;任务6 %@&quot;, [NSThread currentThread]);
       });
       dispatch_async(dispatch_get_global_queue(0, 0), ^{
           NSLog(@&quot;任务7 %@&quot;, [NSThread currentThread]);
       });
    });   
}
</code></pre>
<p>如果将它们队列之间的关系画一张图的话应该是如下图所示（手画的有点丑）：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/7DA841E463C1B07B74B06F79BE0D16C2.png" alt=""></p>
<h2 id="延时执行和队列组"><a href="#延时执行和队列组" class="headerlink" title="延时执行和队列组"></a>延时执行和队列组</h2><h4 id="延时执行"><a href="#延时执行" class="headerlink" title="延时执行"></a>延时执行</h4><p>在iOS中我们常常需要一个方法延时去执行，而实现的方式有很多种，下面的简单的介绍一下常用的几种延时执行的方式</p>
<ol>
<li>使用NSTimer，也就是定时器：</li>
</ol>
<pre><code class="objective-c">NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(task) userInfo:nil repeats:NO];
</code></pre>
<ol>
<li>使用performSelector的方法：</li>
</ol>
<pre><code class="objective-c">[self performSelector:@selector(task) withObject:nil afterDelay:1];
</code></pre>
<ol>
<li>使用GCD实现延时：</li>
</ol>
<pre><code class="objective-c">/*
    1.参数1是表示延时的时间
    2.参数2是队列
    3.参数3是任务
*/
//dispatch_time生成事件，纳秒作为计时单位，精度高
//而且这个方法是异步执行的，效率也更高
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    NSLog(@&quot;延时执行&quot;);
});
</code></pre>
<h4 id="队列组"><a href="#队列组" class="headerlink" title="队列组"></a>队列组</h4><p>之前我们在写实战的Demo的时候，因为需求的原因，在很多队列之间进行跳转和切换，但是有些时候实现这样的功能我们还可以直接的使用队列组，队列组只有异步方法能添加任务，当组里所有任务都执行完后，它会通过一个方法通知我们</p>
<pre><code class="objective-c">- (void)demo{
      //创建组
    dispatch_group_t group = dispatch_group_create();
      //开启异步任务
      dispatch_group_async(group, dispatch_get_global_queue(0,0), ^{
         for (NSInteger i = 0; i &lt; 3; i++) {
          NSLog(@&quot;group-01 - %@&quot;, [NSThread currentThread]);
      }
    });
      //都完成后会自动通知
      dispatch_group_notify(group, dispatch_get_main_queue(), ^{
          NSLog(@&quot;完成 - %@&quot;, [NSThread currentThread]);
      });
}
</code></pre>
<p>下面来说一下dispatch_group_async这个方法的底层调用的是什么方法，如果我们使用一下man命令：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%885.15.15.png" alt=""></p>
<p>如果你使用的是MRC的话，应该就会用到retain和release方法，在ARC中我们可以忽略这两个方法，首先我们会使用<code>dispatch_group_enter(group);</code>进入到这个队列组，然后转到队列中，执行其中的任务,最后使用<br><code>dispatch_group_leave(group);</code>离开这个队列组。</p>
<h2 id="GCD实现单例"><a href="#GCD实现单例" class="headerlink" title="GCD实现单例"></a>GCD实现单例</h2><p>dispatch_once中的代码只会被执行一次，所以我们很容易的就会和单例结合到一起，也就是说如果我们将对象的实例化写到一次性执行中的话，那么我们每次访问的都是同一个对象，因为对象的实例化只会执行一次。</p>
<p>如果是在单线程中的话，可以通过静态变量实现，但是在多线程的情况下，有可能会返回不同的对象，如在单例对象初始化完成之前，多个线程同时访问单例，那么这些进程可能都获得了不同的单例对象，这也是为什么苹果提供了dispatch_once方法的原因。</p>
<pre><code class="objective-c">//自定义类方法
+ (instancetype)defaultObject{  
    static SharedObject *sharedObject = nil;  
    //一次性执行本身就是线程安全的
      static dispatch_once_t predicate;  
    dispatch_once(&amp;predicate, ^{  
        sharedObject = [[SharedObject alloc] init];  
    });  
    return sharedObject;  
}  

static Person *_instance;
//重写allocWithZone函数，alloc底层调用的就是allocWithZone
+ (instancetype)allocWithZone:(struct _NZZone *)zone{
  //加互斥锁解决线程安全问题  
  @synchronized(self){
        if(_instance == nil){
            _instance = [super allocWithZone];
        }
    }
      return _instance;
}

//为了完善同样的话可以重写它的对象方法，但是要先遵守对应的协议
- (id)copyWithZone:(NSZone *)zone{
    return _instance;
}

- (id)mutableCopywithZone:(NSZone *)zone{
    return _instance;
}
//以上就是一个完整的单例方法了
</code></pre>
<p>顺带也要提一下单例模式在MRC中的写法，只需要改动其中部分即可：</p>
<pre><code class="objective-c">//因为单例对象是供全局使用的，所以我们如果正常的release掉肯定会报错
- (oneway void)release{

}

- (instancetype)retain{
    return _instance;
}

//在非ARC环境下，单例对象都会重写其retainCount方法，返回一个最大值
- (NSUInteger)retainCount{
    return MAXFLOAT;
}

//为了实现通用，我们还可以加上一个条件编译
#if __has_feature(objc_arc)
    //不作处理
#else
    //MRC环境，将上面的代码放到这里
#endif
</code></pre>
<p>那么这个<code>dispatch_once</code>函数到底是如何实现线程安全的呢？下面就来解释一下，首先查到dispatch_once_t被定义为长整型，那么 dispatch_once函数是如何让两个同时调用这个方法的进程只执行一次函数的block区块呢？</p>
<p>我们可以通过打印predicate的值发现，在block被访问过之后，这个值会更改为-1，所以我们猜测这个机制是以这个值作为判断条件的：</p>
<p> <img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-05%20%E4%B8%8B%E5%8D%886.03.41.png" alt=""></p>
<p>如果可以参考一下这个函数的实现进行分析的话就会有更加直观的理解，所以现在对于其中真正的多线程保护逻辑还是并不清楚的，通过查看了其中一堆乱七八糟的宏定义之后更加蒙圈了..</p>
<h4 id="单例模式的抽取"><a href="#单例模式的抽取" class="headerlink" title="单例模式的抽取"></a>单例模式的抽取</h4><p>在一个项目中，我们往往用到的不止一个单例对象，如果每次要实现单例对象的时候都把上面的代码复制修改一下，又未免显得过于繁琐，于是我们想到是否能用<code>继承</code>来解决这个问题，经过试验之后发现其实是不可行的，继承过去之后因为那个静态变量也是继承的，只能被调用一次，所以如果是继承关系的话，谁先实例化那么这个单例对象就是谁，无法达到我们想要的效果：</p>
<pre><code class="objective-c">//我们可以把单例的代码抽取出来变成一个宏
#define SingleH +(instancetype)shareTool;
#define SingleM //单例代码部分,但是注意要用连接符链接，不然就只是宏定义的就只要单独的一行
</code></pre>
<p>写到这里还是不够好，因为为了要应对不同的单例对象，生成的单例对象名字应该作为一个参数传入：</p>
<pre><code class="objective-c">#define SingleH(name) +(instancetype)share##name;
</code></pre>
<p>如果是在MRC环境下，因为条件编译是不能放在宏里面的，所以就把宏放在条件编译里面，形成最后的完整版</p>
<pre><code class="objective-c">#define SingleH(name) +(instancetype)share##name;
#if __has_feature(objc_arc)
    //ARC的宏
#else
    //MRC的宏
#endif
</code></pre>
<h2 id="GCD中的栅栏函数"><a href="#GCD中的栅栏函数" class="headerlink" title="GCD中的栅栏函数"></a>GCD中的栅栏函数</h2><p>栅栏函数一般用于在异步并行队列中分割队列中的任务执行，如现在有个需求是先并发执行1，2任务，再执行3。那么就可以在中间插入一个栅栏函数，但是有一点要注意的是，栅栏函数不能使用全局并发队列。</p>
<pre><code class="objective-c">//手动创建一个并发队列
dispatch_queue_t queue = dispatch_queue_create(&quot;download&quot;, DISPATCH_QUEUE_CONCURRENT);
dispatch_async(queue, ^{
   NSLog(@&quot;download1--%@&quot;,[NSThread currentThread]); 
});
dispatch_async(queue, ^{
   NSLog(@&quot;download2--%@&quot;,[NSThread currentThread]); 
});
dispatch_barrier_async(queue, ^{
   NSLog(@&quot;++++++++&quot;); 
});
dispatch_async(queue, ^{
   NSLog(@&quot;download3--%@&quot;,[NSThread currentThread]); 
});
</code></pre>
<p>从打印结果可以看出已经生效：<img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-06%20%E4%B8%8A%E5%8D%8812.39.36.png" alt=""></p>
<p>接下来就来列举一下栅栏函数在不同的使用环境下所产生的效果：</p>
<p>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)  //异步</p>
<ul>
<li>与dispatch_get_global_queue(0, 0);(全局并发队列)一起使用,达不到栅栏的效果,官方文档有说;</li>
<li>与dispatch_get_main_queue()(主队列)一起使用,barrier前后任务串行执行,都在UI线程执行</li>
<li>与dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL)(串行队列)一起使用,会创建一个线程,barrier前后的任务串行执行</li>
<li>与dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT)(自定义并发队列)一起使用,创建多个线程,barrier前后的任务都是并行执行.</li>
</ul>
<p>dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)  //同步</p>
<ul>
<li>与dispatch_get_global_queue(0, 0);(全局并发队列)一起使用,达不到栅栏的效果,官方文档有说;</li>
<li><strong>与dispatch_get_main_queue()(主队列)一起使用,程序会进入死锁状态!!!!!!!!(这个很容易忽略)</strong></li>
<li>与dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL)(串行队列)一起使用,barrier在UI线程运行</li>
<li>与dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT)(自定义并发队列)一起使用,barrier在UI线程运行</li>
</ul>
<p>所以一般栅栏函数都是会使用异步的（因为同步压根没有什么卵用，还容易造成线程死锁）</p>
<h2 id="GCD快速迭代"><a href="#GCD快速迭代" class="headerlink" title="GCD快速迭代"></a>GCD快速迭代</h2><p>一般我们在for循环中任务都是在同一个线程中顺序执行的，但是这样的行为在我们对于for循环中的任务执行顺序没有要求的时候，显然是非常的浪费资源的，这个时候我们就可以使用GCD快速迭代来实现资源的有效利用：</p>
<pre><code class="objective-c">/*
第一个参数：遍历的次数
第二个参数：队列（并发队列）
第三个参数：索引
*/
dispatch_apply(10, dispatch_get_global_queue(0,0), ^(size_t index){
    NSLog(@&quot;---%@&quot;, index, [NSThread currentThread]);
});
</code></pre>
<p>比如我们要遍历一个目录下面的所有文件然后剪切到另一个目录下面</p>
<pre><code class="objective-c">- (void)moveFile{
  NSString from = @&quot;/Users/test/Desktop/from&quot;;

  NSString *to = @&quot;/Users/test/Desktop/to&quot;;

  NSArray *subPaths = [[NSFileManager defaultmanager] subpathsAtPath:from];

  NSInteger count = subPaths.count;

  dispatch_apply(count, dispatch_get_global_queue(0,0), ^(size_t index){

  NSString *fullPath = [from stringByAppendingPathComponent:subPath[index]];

  NSString *toFullPath = [to stringByAppendingPathComponent:subPath[index]];

  [[NSFileManager defaultManager] moveItemAtPath:fullPath toPath:toFullPath error:nil];

  });
}
</code></pre>
<h2 id="GCD补充"><a href="#GCD补充" class="headerlink" title="GCD补充"></a>GCD补充</h2><p>一般我们在异步执行的时候调用的都是<code>dispatch_async</code>方法，GCD中还提供了另外一种方法，不同的是它们封装任务的方法，<code>dispatch_async</code>是使用block的方式来封装任务，而<code>dispatch_async_f</code>是通过函数的方式来进行封装：</p>
<pre><code class="objective-c">dispatch_async_f(dispatch_get_global_queue(0, 0), NULL, task);
dispatch_async_f(dispatch_get_global_queue(0, 0), NULL, task);

void task(void *param){
    NSLog(@&quot;%@---%@&quot;, __func__, [NSthread currentThread]);
}
</code></pre>
<p>参考博客</p>
<ul>
<li><a href="http://blog.csdn.net/mlibai/article/details/46945331" target="_blank" rel="external">dispatch_once剖析</a></li>
<li><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="external">关于iOS多线程，你看我就够了</a></li>
<li><a href="http://www.jianshu.com/p/481e4bef1bd6" target="_blank" rel="external">iOS中的多线程学习笔记</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/05/iOS多线程之GCD/" data-id="cjf3m9k7a004pg3brtf5r22fa" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/10/07/GFW-中间人攻击/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          GFW&amp;中间人攻击
        
      </div>
    </a>
  
  
    <a href="/2017/09/29/iOS多线程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">iOS多线程</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Peterpan&#39;s Blog</h1>
    <h2 class="blog-subtitle">Mind over muscle.</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%8811.42.23.png">
    <h2 class="author">Peter pan</h2>
    <h3 class="description">the mark of an educated mind is to be able to entertain a thought without accepting it</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>86</strong><br>文章</div></a>
      <a href="/categories"><div><strong>80</strong><br>分类</div></a>
      <a href="/tags"><div><strong>14</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/Peterpan0927" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="https://www.imbajin.com" target="_blank" title="Jin">
          Jin
        </a>
      
        <a class="hvr-bounce-in" href="https://yinwang0.wordpress.com" target="_blank" title="Yinwang(English)">
          Yinwang(English)
        </a>
      
        <a class="hvr-bounce-in" href="http://www.yinwang.org" target="_blank" title="Yinwang(Chinese)">
          Yinwang(Chinese)
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 Peter pan<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/about" title="" class="menuItem">音乐</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="https://github.com/Peterpan0927" title="" class="menuItem">Github</a>
          
            <a href="ftp://118.89.38.168" title="" class="menuItem">FTP</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>