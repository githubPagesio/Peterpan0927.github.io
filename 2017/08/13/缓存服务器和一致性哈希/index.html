<html>
<head>
	
	<title>缓存服务器和一致性哈希</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">缓存服务器和一致性哈希</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年8月13日


    <a class="article-category-link" href="/categories/一致性和非一致性hash-分布式/">一致性和非一致性hash 分布式</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存服务器和一致性哈希"><span class="toc-text">缓存服务器和一致性哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存服务器"><span class="toc-text">缓存服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一致性哈希"><span class="toc-text">一致性哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#负载均衡和哈希算法"><span class="toc-text">负载均衡和哈希算法</span></a></li></ol></li></ol></li></ol>
<p>关于hash算法在服务器端的应用是怎么样的呢？<br><a id="more"></a></p>
<h1 id="缓存服务器和一致性哈希"><a href="#缓存服务器和一致性哈希" class="headerlink" title="缓存服务器和一致性哈希"></a>缓存服务器和一致性哈希</h1><h2 id="缓存服务器"><a href="#缓存服务器" class="headerlink" title="缓存服务器"></a>缓存服务器</h2><p>缓存服务器相对于一般服务器的作用就是提速，因为缓存服务器是直接从内存中读取数据，相对于从硬盘中读取数据，这个速度要快了至少十万倍。</p>
<p>那么缓存服务器相对于一般的服务器是如何优化的呢？</p>
<pre><code class="javascript">//一般的提取数据方法
var data = Database.get(111);  // 从数据库拿数据，慢
return data;
</code></pre>
<pre><code class="javascript">//从缓存服务器中提取数据
var myAwesomeCache = {};  // 我们的缓存，只是内存中一个字典

...

var data = myAwesomeCache[&#39;111&#39;];  // 先从内存拿，快
if (data != null) {
    return data;  // 有就直接用
}

data = Database.get(&#39;111&#39;);  // 没有才从数据库拿
myAwesomeCache[&#39;111&#39;] = data;  // 而且拿完记得加进缓存
return data;
</code></pre>
<p>添加缓存前，由于每次请求都从数据库中拿数据，需要通过网络／磁盘，速度慢，数据库压力大。</p>
<p>现在将结果放在内存中做缓存，如果后面的请求命中了这个缓存，就能直接从内存中获取数据，而内存显然比网络／磁盘快的多。</p>
<p>通常来说内存虽然速度比磁盘快，但成本高，容量小。但是断电会失效。</p>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><h3 id="负载均衡和哈希算法"><a href="#负载均衡和哈希算法" class="headerlink" title="负载均衡和哈希算法"></a>负载均衡和哈希算法</h3><p>分布式系统中（如：web存储），当服务增长到一定规模时，惯常的方法就是集群化，引入负载均衡，这样做的好处是：1.高可用。2.解耦。从外部看，透明了集群的内部细节（外部通过负载均衡服务器通信，然后由负载均衡服务器分发请求）。</p>
<p>假设有四个cache服务器组成的集群，当一个对象object传入集群时，这个对象应该存储到哪一个cache中呢？一种简单的方法就是用映射公式：</p>
<pre><code class="matlab">Hash(object)%4
</code></pre>
<p>这个算法就可以保证任何object都会尽可能随机落在其中一个cache中。</p>
<p>然后考虑以下情况：</p>
<ul>
<li>由于流量增大，需要增加一台cache，这个时候，映射公式就变成<code>Hash(object)%5</code></li>
<li>有一台cache服务器down掉，这个时候，映射公式就变成<code>Hash(object)%3</code></li>
</ul>
<p>可见，无论是新增还是减少剪掉，都会改变映射公式，由于映射公式改变，几乎所有的object都会被object都会被映射到新的cache中，这意味着一时间所有的缓存都会全部失效。因为所有的缓存都要重新的分配</p>
<p>如要分配2，3，4，5四个数，首先对2取模：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%889.45.18.png" alt=""></p>
<p>这个时候如果嫌桶的数量少了，对3取模，结果就变成了：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%889.46.51.png" alt=""></p>
<p>可以看到新加了一个桶后所有数字的分布都变了，这就意味着哈希表的每次扩展和收缩都会导致所有条目分布的重新计算，这种情况在cache服务器的文件分配上就是不可接受的了。</p>
<p>所以我们需要采用非一致性哈希算法,，一致性哈希中假想我们有很多个桶，先定一个小目标比如 7 个，但一开始真实还是只有两个桶，编号是 3 和 6。哈希算法还是同样的取模，只不过现在分桶分到的很可能是不存在的桶，那么就往下找找到第一个真实存在的桶放进去。这样 2 和 3 都被分到了编号为 3 的桶， 4 和 5 被分到了编号为 6 的桶。</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%889.49.00.png" alt=""></p>
<p>这时候再添加一个新的桶，编号是 4，取模方法不变还是模 7：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%889.49.22.png" alt=""></p>
<p>因为 3 号桶里都是取模小于等于 3 的，4 号桶只需要从 6 号桶里拿走属于它的数字就可以了，这种情况下只需要调整一个桶的数字就可分成了重新分布。可以想象下即使有 1 亿个桶，增加减少一个桶也只会影响一个桶的数据分布。</p>
<p>这样增加一个机器只需要和他后面的机器同步一下数据就可以开始工作了，下线一个机器需要先把他的数据同步到后面一台机器再下线。如果突然掉了一台机器也只会影响这台机器上的数据。实现中可以让每台机器同步一份自己前面机器的数据，这样即使掉线也不会影响这一部分的数据服务。</p>
<p>这里还有个小问题要是编号为 6 的机桶下线了，它没有后一个桶了，数据该咋办？为了解决这个问题，实现上通常把哈希空间做成环状，这样 3 就成了 6 的下一桶，数据给 3 就好了：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%889.52.24.png" alt=""></p>
<p>应用到我们的缓存服务器当中，这种算法就是非常合适的，将cache作为桶，object作为数字，避免了大量的数据迁移，减少了服务器的压力。但是受限于cache服务器的数量（桶的数量），无法满足平衡性，所有又引入了虚拟节点：虚拟节点”（ virtual node ）是实际节点（机器）在 hash 空间的复制品，一个实际节点（机器）对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以hash值排列。</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-07-05%20%E4%B8%8B%E5%8D%8810.04.30.png" alt=""></p>
<p>这样也就满足了平衡性了，可以广泛的进行应用。</p>


<!--<a href="http://yoursite.com/2017/08/13/缓存服务器和一致性哈希/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>