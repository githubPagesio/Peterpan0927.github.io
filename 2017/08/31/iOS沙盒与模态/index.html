<html>
<head>
	
	<title>iOS沙盒与模态</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">iOS沙盒与模态</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年8月31日


    <a class="article-category-link" href="/categories/沙盒结构-数据持久化-模态控制器/">沙盒结构 数据持久化 模态控制器</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#iOS沙盒与模态"><span class="toc-text">iOS沙盒与模态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS应用存储数据常用方式"><span class="toc-text">iOS应用存储数据常用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用沙盒结构分析"><span class="toc-text">应用沙盒结构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#沙盒目录结构"><span class="toc-text">沙盒目录结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#打开应用沙盒"><span class="toc-text">打开应用沙盒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#沙盒机制的好处"><span class="toc-text">沙盒机制的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取路径"><span class="toc-text">获取路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-沙盒路径"><span class="toc-text">1.沙盒路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Documents路径"><span class="toc-text">2.Documents路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Tmp路径"><span class="toc-text">3.Tmp路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Library路径"><span class="toc-text">4.Library路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-应用程序包路径"><span class="toc-text">5.应用程序包路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plist文件存储"><span class="toc-text">plist文件存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归档和反归档"><span class="toc-text">归档和反归档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UITabBarController"><span class="toc-text">UITabBarController</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#纯代码创建方式"><span class="toc-text">纯代码创建方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过Storyboard加载tabBarController"><span class="toc-text">通过Storyboard加载tabBarController</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#App主流框架结构"><span class="toc-text">App主流框架结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模态出控制器"><span class="toc-text">模态出控制器</span></a></li></ol></li></ol></li></ol>
<p>ios为何安全？数据是如何存储？控制器在频繁地切换间生命周期是怎样的？欢迎观看今日说ios~<br><a id="more"></a></p>
<h1 id="iOS沙盒与模态"><a href="#iOS沙盒与模态" class="headerlink" title="iOS沙盒与模态"></a>iOS沙盒与模态</h1><h2 id="iOS应用存储数据常用方式"><a href="#iOS应用存储数据常用方式" class="headerlink" title="iOS应用存储数据常用方式"></a>iOS应用存储数据常用方式</h2><ul>
<li><p>XML属性列表（plist）归档</p>
</li>
<li><p>Preference（偏好设置）</p>
<p>本质还是通过plist文件存储数据，但是使用更简单（不需要关注文件，文件夹路径和名称）</p>
</li>
<li><p>NSKeyedArchiver归档（NSCoding）</p>
<p>把任何对象，直接保存为文件的方式</p>
</li>
<li><p>SQLite3</p>
<p>当非常大的数据存储时使用</p>
</li>
<li><p>Core Data</p>
<p>对SQLite3的封装</p>
</li>
</ul>
<h2 id="应用沙盒结构分析"><a href="#应用沙盒结构分析" class="headerlink" title="应用沙盒结构分析"></a>应用沙盒结构分析</h2><p>每个ios应用都有自己的应用沙盒，沙盒机制规定每个应用都只能访问当前沙盒目录下面的文件（也有例外，比如在用户授权情况下访问通讯录，相册等），这个规则展示了iOS系统的封闭性。在开发中常常需要数据存储的功能，比如存取文件，归档解档等。</p>
<h3 id="沙盒目录结构"><a href="#沙盒目录结构" class="headerlink" title="沙盒目录结构"></a>沙盒目录结构</h3><ol>
<li><p>Documents(文档数据)<br>保存应用运行时生成的需要持久化的数据，iTunes同步设备时会备份该目录，如游戏进度存档等。</p>
</li>
<li><p>Library(资源库)<br>Library下默认有两个文件夹，Caches文件夹和tmp文件夹</p>
<blockquote>
<p>a. Caches(缓存)<br>保存应用运行时生成的需要持久化的数据，iTunes同步设备时不会备份该目录。该文件夹一般用于存储体积大、不需要备份的非重要数据</p>
<p>b. Preferences(偏好设置)<br>保存应用的所有偏好设置，ios的Settings(设置)，应用会在该目录中查找应用的设置信息。iTunes同步设备时会备份该目录，通常存储一些基本的软件配置信息，比如记住密码，自动登录等。</p>
</blockquote>
</li>
<li><p>tmp(临时文件目录)<br>保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时不会备份该目录。iPhone在重启时，会丢弃所有的tmp文件</p>
</li>
</ol>
<p>我们平时操作的数据主要使用Documents目录</p>
<h2 id="打开应用沙盒"><a href="#打开应用沙盒" class="headerlink" title="打开应用沙盒"></a>打开应用沙盒</h2><p>应用沙盒是在MAC的资源库（Library目录下），资源库文件夹默认是隐藏的,要显示隐藏的资源库才能查看iPhone模拟器的应用沙盒。</p>
<p>1.显示隐藏的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#显示Mac隐藏的文件</div><div class="line">defaults write com.apple.finder AppleShowAllFiles YES</div><div class="line">#隐藏Mac隐藏文件</div><div class="line">defaults write com.apple.finder AppleShowAllFiles NO</div><div class="line">#输入以上的命令之后，重新启动finder即可</div></pre></td></tr></table></figure>
<p>2.安装<strong>SimPholders</strong>应用程序，该应用可以轻松查看每一个应用程序的应用沙盒</p>
<h3 id="沙盒机制的好处"><a href="#沙盒机制的好处" class="headerlink" title="沙盒机制的好处"></a>沙盒机制的好处</h3><p>1.安全：别的App无法修改你的程序或数据</p>
<p>2.保护隐私：别的App无法读取你的程序和数据</p>
<p>3.方便删除：因为一个App中所有的内容都在自己的沙盒中，所以删除沙盒就可以彻底删除程序</p>
<h2 id="获取路径"><a href="#获取路径" class="headerlink" title="获取路径"></a>获取路径</h2><h3 id="1-沙盒路径"><a href="#1-沙盒路径" class="headerlink" title="1.沙盒路径"></a>1.沙盒路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *path = NSHomeDirectory();</div><div class="line">NSLog(@&quot;%@&quot;, path);</div><div class="line">NSLog(@&quot;%@&quot;, [NSBundle mainBundle].bundlePath);</div></pre></td></tr></table></figure>
<h3 id="2-Documents路径"><a href="#2-Documents路径" class="headerlink" title="2.Documents路径"></a>2.Documents路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// NSDocumentDirectory：目标文件夹</div><div class="line">   // NSUserDomainMask：作用域</div><div class="line">   // YES：是否展开波浪线</div><div class="line">   // 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素，用firstObject取第一个元素</div><div class="line">   NSString *documentsPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES).firstObject;</div><div class="line"></div><div class="line">   NSLog(@&quot;%@&quot;,documentsPath);</div></pre></td></tr></table></figure>
<h3 id="3-Tmp路径"><a href="#3-Tmp路径" class="headerlink" title="3.Tmp路径"></a>3.Tmp路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSString *tmpPath = NSTemporaryDirectory();</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,tmpPath);  </div><div class="line">//或者使用沙盒根目录进行拼接</div><div class="line">NSString *homePath = NSHomeDirectory();</div><div class="line"></div><div class="line">// 不建议采用，因为新版本的操作系统可能会修改目录名</div><div class="line">NSString *tmpPath = [homePath stringByAppendingPathComponent:@&quot;tmp&quot;];</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,tmpPath);</div></pre></td></tr></table></figure>
<h3 id="4-Library路径"><a href="#4-Library路径" class="headerlink" title="4.Library路径"></a>4.Library路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Caches路径</div><div class="line">NSString *filePath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory,    </div><div class="line">                         NSUserDomainMask, YES).firstObject;</div><div class="line">//Preference路径                         </div><div class="line">NSString *filePath = NSSearchPathForDirectoriesInDomains</div><div class="line">  (NSPreferencePanesDirectory, NSUserDomainMask, YES).firstObject;</div></pre></td></tr></table></figure>
<h3 id="5-应用程序包路径"><a href="#5-应用程序包路径" class="headerlink" title="5.应用程序包路径"></a>5.应用程序包路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> NSString *imagePath = [NSBundle mainBundle].resourcePath;</div><div class="line">//获取目录下一个图片的路径</div><div class="line"> NSString *imagePath = [[NSBundle mainBundle]pathForResource:@&quot;apple&quot; ofType:@&quot;png&quot;];</div></pre></td></tr></table></figure>
<h2 id="plist文件存储"><a href="#plist文件存储" class="headerlink" title="plist文件存储"></a>plist文件存储</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">NSArray *names = [NSArray arrayWithObjects:@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, nil];</div><div class="line"></div><div class="line">NSString *path = [NSSearchPathForDirectoryInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];</div><div class="line"></div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;names.plist&quot;];</div><div class="line">//参数二是是否允许原子型写入</div><div class="line">[names writeToFile:filePath atomically:YES];</div><div class="line"></div><div class="line">//偏好设置存储，单例对象</div><div class="line">NSUserDefaults *userDefaults= [NSUserDefaults standardUserDefaults];</div><div class="line">//设置数据</div><div class="line">[userDefaults setBool:YES forKey:@&quot;isTrue&quot;];</div><div class="line">[userDefaults setObject:@&quot;124&quot; forKey:@&quot;number&quot;];</div><div class="line">//立即存储</div><div class="line">[userDefaults synchronize];</div></pre></td></tr></table></figure>
<h2 id="归档和反归档"><a href="#归档和反归档" class="headerlink" title="归档和反归档"></a>归档和反归档</h2><p>通过plist可以保存数据，但是无法直接将对象保存到一个文件当中。比如自己创建的一个Person对象就没有writeToFile方法。但是我们可以通过归档的方式将任何遵守NSCoding协议的对象存储到文件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//首先在这个类中要遵从NSCoding协议，并且在这个类中实现代理方法</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</div><div class="line">    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];</div><div class="line">  	[aCoder encodeObject:self.phoneNumber forKey:@&quot;phoneNumber&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Person *person = [[Person alloc] init];</div><div class="line">person.name = @&quot;tom&quot;;</div><div class="line">person.phoneNumber= @&quot;10010&quot;;</div><div class="line">NSString *path = [NSSearchPathForDirectoryInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;contact.plist&quot;];</div><div class="line">//通过归档的方式存储</div><div class="line">[NSKeyedArchiver archiveRootObject:person toFile:fileName];</div></pre></td></tr></table></figure>
<p>同时我们也可以通过反归档的方式，将文件重新还原成对象，同样也要遵从NSCoding协议：ee</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//实现反归档的代理方法</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123;</div><div class="line">    if(self = [super init])&#123;</div><div class="line">        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">      	self.phoneNumber = [aDecoder decodeObjectForKey:@&quot;phoneNumber&quot;];</div><div class="line">    &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">NSString *path = [NSSearchPathForDirectoryInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;contact.plist&quot;];</div><div class="line">//进行反归档</div><div class="line">Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:filename];</div></pre></td></tr></table></figure>
<h2 id="UITabBarController"><a href="#UITabBarController" class="headerlink" title="UITabBarController"></a>UITabBarController</h2><h3 id="纯代码创建方式"><a href="#纯代码创建方式" class="headerlink" title="纯代码创建方式"></a>纯代码创建方式</h3><p>和导航控制器相对的，这个相当于是底部的导航控制器，其创建方式和导航控制器也非常的类似，记得要把info.plist中的那个”Main”删掉啊：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">self.window= [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];</div><div class="line"></div><div class="line">UITabBarController *tabBarVc = [UITabBarViewController alloc] init];</div><div class="line"></div><div class="line">tabBarVc.view.backgroundColor = [UIColor redColor];</div><div class="line"></div><div class="line">PController *pVc = [[PController alloc] init];</div><div class="line"></div><div class="line">[tabBarVc addChildViewController: pVc];</div><div class="line"></div><div class="line">self.window.rootViewController = tabBarVc;</div><div class="line"></div><div class="line">[self.window makeKeyAndVisible];</div><div class="line">//添加子控制器的时候还可以像下面这样一起添加</div><div class="line">tabBarVc.viewControllers = @[pVc, pVc1];</div></pre></td></tr></table></figure>
<p>那么如果要给它加上诸如联系人、空间之类的标题图片要怎么做呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pVc.tabBarItem.title = @&quot;Peterpan&quot;;</div><div class="line">pVc.tabBarItem.image = [UIImage imageNamed:@&quot;peterpan&quot;];</div></pre></td></tr></table></figure>
<p>然后就会形成下面这样的效果(不要吐槽我的画质，开心就好～)</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-29%20%E4%B8%8B%E5%8D%8811.23.23.png" alt=""></p>
<p>这个时候发现图片居然是蓝色的？？？这是因为high_lighted状态系统默认会渲染成蓝色，如果要修改的话可以这样写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//修改图片的渲染模式</div><div class="line">selectImage = [selectImage imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];</div><div class="line">pVc.tabBarItem.selectedImage = selectImage;</div></pre></td></tr></table></figure>
<h3 id="通过Storyboard加载tabBarController"><a href="#通过Storyboard加载tabBarController" class="headerlink" title="通过Storyboard加载tabBarController"></a>通过Storyboard加载tabBarController</h3><p>如果是从控件栏中拖入一个tabBarController，会一次性附加两个控制器，同时别忘了给tabBarController加上箭头，因为storyboard默认加载箭头指向的控制器。同时在附加控制器连线的时候，不同于导航控制器的show，而是点击之前的一条连线，有一个viewControllers，将之连到要加入的控制器即可。</p>
<p>接下来说一下UITabBarButton中的一些属性，可以参考导航控制器的。</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/891D21A5B819BE4CF04B2C9C607C0950.jpg" alt=""></p>
<p>这个地方要说一点，就是和导航控制器不同的是，tabBarController的子控制器在进行切换的时候<code>不会被销毁</code>，导航控制器在切换子控制器的时候会将该子控制器上面的控制器弹出并销毁。</p>
<h3 id="App主流框架结构"><a href="#App主流框架结构" class="headerlink" title="App主流框架结构"></a>App主流框架结构</h3><p><img src="http://omunhj2f1.bkt.clouddn.com/FCEFA1AAE0F65D78D5706A12306E39A6.jpg" alt=""></p>
<p>主流框架就是通过tabBarController配合导航控制器来使用，qq也是这样做的</p>
<p>首先加载一个tabBarController，然后根据用户的点击选择跳转不同的导航控制器，导航控制器中再分别设置视图控制器等，如果动态那一栏可以使用静态单元格。</p>
<p>其中有一些逻辑是需要我们注意的：</p>
<p>1.在我们通过底部的按钮加载导航控制器之后，导航控制器内push的时候，tabBar需要隐藏，点击需要隐藏的控制器，右侧栏的layout那里有一个选项，勾选即可：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/30299C863BC1649EE7158C41B0B2E559.jpg" alt=""></p>
<p>2.如果是静态单元格的话，可以直接选中tableViewCell来进行拖线的方式进行跳转</p>
<h3 id="模态出控制器"><a href="#模态出控制器" class="headerlink" title="模态出控制器"></a>模态出控制器</h3><p>模态也是一种切换控制器显示的方法（之前是通过push和pop），任何控制器都可以通过模态来显示。</p>
<p>模态的默认效果是新控制器从屏幕底下往上钻，直到覆盖原来的控制器为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;NewViewController.h&quot;</div><div class="line"></div><div class="line">@interface ViewController()</div><div class="line">  </div><div class="line">@end</div><div class="line">  </div><div class="line">@implementation ViewController</div><div class="line">  </div><div class="line">- (IBAction)btnClick:(id)sender&#123;</div><div class="line">    NewViewController *new = [[NewViewController alloc] init];</div><div class="line">  </div><div class="line">	//设置代理</div><div class="line">  	new.delegate = self;</div><div class="line">  	</div><div class="line">  	[self presentViewController:new animated:YES completion:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>如果是推出控制器的时候，要是用代理的模式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//.h文件中设置代理</div><div class="line">@protocol NewViewControllerDelegate &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)newControllerDismissBtnClick:(NewViewController *)newVc;</div><div class="line">  </div><div class="line">@end</div><div class="line">- (IBAction)dismissClick:(id)sender&#123;</div><div class="line">    if([self.delegate respondsToSelector:@selector(newViewControllerDismissBtnClick)])&#123;</div><div class="line">        [self.delegate newViewControllerDismissBtnClick:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//在viewController中实现方法</div><div class="line">- (void)newControllerDismissBtnClick:(NewViewController *)newVc&#123;</div><div class="line">  //这个方法首先会判断自己是不是被present出来的，如果是的，就销毁</div><div class="line">    [self dismissViewControllerAnimated:YES completion:nil];</div><div class="line">&#125;</div><div class="line">//但是这里一般不会用代理hhh，是不是觉得被骗了，直接dismiss就好了</div></pre></td></tr></table></figure>
<p>但是在控制器中间放一个按钮始终感觉非常的奇怪，所以我们一般在使用的时候可以把要显示的控制器包装在一个导航控制器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (IBAction)btnClick:(id)sender&#123;</div><div class="line">    NewViewController *new = [[NewViewController alloc] init];</div><div class="line"></div><div class="line">  	UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController: new];</div><div class="line">  	//创建导航栏最左侧按钮</div><div class="line">  	new.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCancel target:self action:@selector(dismissClick)];</div><div class="line">  </div><div class="line">  	[self presentViewController:nav animated:YES completion:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想用storyboard来实现当然也是可以的，只不过把之前的show换成Present-Modaily，转场效果可以自己设置哦～，个人觉得旋转的比较炫酷一点。</p>


<!--<a href="http://yoursite.com/2017/08/31/iOS沙盒与模态/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>