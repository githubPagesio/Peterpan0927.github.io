<html>
<head>
	
	<title>Python-函数式编程</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">Python-函数式编程</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年11月6日


    <a class="article-category-link" href="/categories/函数式编程/">函数式编程</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map-reduce"><span class="toc-text">map/reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter-sorted"><span class="toc-text">filter/sorted</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#返回函数"><span class="toc-text">返回函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装饰器"><span class="toc-text">装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#偏函数"><span class="toc-text">偏函数</span></a></li></ol>
<p>当看到函数式编程的语法的时候就感觉自己被深深的吸引了，这是养成函数式编程范式的第一步。</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>也许继面向对象之后，函数式编程会成为下一个主流的编程范式，其实与其在语言中说这个不如说是函数式编程的思想。首先函数式编程的代码非常容易理解，偏向自然语言，而且函数式编程不依赖也不会改变外界的状态。因此每一个函数都可以看作独立单元，这样有利于模块化组合。</p>
<p>其次它有利于并发编程，我们不需要去考虑死锁的问题，因为它根本不会修改变量，所以我们可以很放心的把任务分摊到多个线程，部署并发编程。</p>
<h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h2><p>显然map/reduce是函数式编程中非常经典的部分了，首先看看map，<code>map()</code>函数接受两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用于序列中的每一个元素，并把结果作为新的<code>Iterator</code>返回（Python3中是这样，而在python2中返回的仍然是一个<code>Interable</code>）.下面举个例子</p>
<pre><code class="python">&gt;&gt;&gt;def f(x):
...        return x
...
&gt;&gt;&gt;r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&gt;&gt;&gt;list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
</code></pre>
<p>这里因为<code>map()</code>返回的是一个<code>Interator</code>，<code>Interator</code>是一个惰性序列，因此通过<code>list()</code>函数计算出整个序列返回。虽然这个我们使用for循环同样可以做到，但是无法一眼看出来目的，而且代码冗长。</p>
<p>所以,<code>map()</code>作为高阶函数，事实上他把运算规则抽象了，我们除了计算上面的之外还可以计算任意复杂的函数，如：</p>
<pre><code class="python">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
</code></pre>
<p>再看<code>reduce</code>的用法。<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre><code class="python">&gt;&gt;&gt;from functools import reduce
&gt;&gt;&gt;def add(x, y):
...        return x+y
...
&gt;&gt;&gt;reduce(add, [1, 3, 5, 7, 9])
25
</code></pre>
<p>因为python中已经有<code>sum()</code>内置函数做加法了，如果这个时候要将上面的列表变成<code>13579</code>，reduce就可以派上用场了</p>
<pre><code class="python">&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; def fn(x, y):
...     return x * 10 + y
...
&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])
13579
</code></pre>
<p>这个例子本身没有多大用，如果考虑到字符串也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，就可以自己手写一个<code>str</code>转<code>int</code>了，这里先提前使用一下lambda函数：</p>
<pre><code class="python">from functools import reduce

keys = [str(x) for x in range(9)]
values = range(9)
the_dict = dict(zip(keys, values))

def char2num(s):
    return the_dict[s]
def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
</code></pre>
<p>这样就算不掉用python的<code>int()</code>函数也可以自己写一个将字符串转换成整数的函数，下面就来做几个练习来巩固一下；</p>
<ol>
<li>利用<code>map()</code>函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：<code>[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]</code>，输出：<code>[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]</code>：</li>
</ol>
<pre><code class="python">def normalize(name):
    return name[0].upper()+name[1:].lower()
L1 = [&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]
L2 = list(map(normalize, L1))
print(L2)
</code></pre>
<ol>
<li>Python的<code>sum()</code>函数可以接受一个list并求和，编写一个<code>prod()</code>函数，可以接受一个list并利用reduce()求积：</li>
</ol>
<pre><code class="python">def prod(L):
    return reduce(lambda x, y: x * y, L)
</code></pre>
<ol>
<li>利用<code>map</code>和<code>reduce</code>编写一个<code>str2float</code>函数，把字符串<code>&#39;123.456&#39;</code>转换成浮点数<code>123.456</code>：</li>
</ol>
<pre><code class="python">#-*- coding:utf-8 -*-
from __future__ import division #兼容python2
from functools import reduce

def str2int(s):
    def char2num(c):
        return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5,&#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[c]
    return reduce(lambda x, y: x *10 + y, map(char2num, s))

def str2float(s):
    s_list = s.split(&#39;.&#39;)            
    float_i = str2int(s_list[0])     
    float_f = 0.1
    float_f = str2int(s_list[1]) / (10**len(s_list[1]))
    return float_i + float_f

print(str2float(&#39;123.456&#39;))
</code></pre>
<h2 id="filter-sorted"><a href="#filter-sorted" class="headerlink" title="filter/sorted"></a>filter/sorted</h2><p>python内建的<code>filter()</code>函数用于过滤序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每一个元素，然后跟据返回的值是True还是False决定保留还是丢弃该元素。下面举几个例子：</p>
<pre><code class="python">def is_ord():
  return n %2 ==1
list(filter(is_ord, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]

def not_empty(n):
  return s and s.strip()
list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))
# 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
</code></pre>
<p>我们可见<code>filter()</code>旨在做筛选，和<code>map()</code>一样，它返回的也是一个<code>Iterator</code>，也就是一个惰性序列，我们可以利用filter实现一个计算素数的方法—埃氏筛法：</p>
<pre><code class="python">#首先构造一个从3开始的奇数序列
def _odd_iter():
      n = 1
      while True:
          n = n + 2
        yield n
#定义一个筛选函数
def _not_divisible(n):
      return lambda x: x % n &gt; 0
#定义一个生成器，不断返回下一个素数
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
#设置调用条件，打印1000以内的素数:
for n in primes():
    if n &lt; 1000:
        print(n)
    else:
        break
</code></pre>
<p>我们都知道在C语言中有一个练习是判断一个字符串是不是回文串，那么使用python的<code>filter()</code>去实现的话就很简单了</p>
<pre><code class="python">L = [12321, 565, 2222,34343]
print(filter(lambda: x == int(str(x)[::-1], L)))
</code></pre>
<p>同时排序也是程序中会经常用到的算法，但是有时候我们需要根据我们的需求进行不同衡量标准的排序，这个时候我们就可以使用python中名为<code>sorted()</code>的高阶函数，这个函数中有一参数是key，我们可以根据需要传入排序衡量的标准，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过<code>key=abs</code>处理过的list，也许你觉得这样说有点抽象，那么我们就来举个例子：</p>
<pre><code class="python">#正常数字排序是从小到大
&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]
#但是我们可以选择按照绝对值去排序
&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)
#如果需要反向排序，只需要添加第三个参数
&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs, reverse=True)
</code></pre>
<p>也许你会说这似乎也没什么了不起的，还是在排序罢了，那么接下来就介绍一下如果给我们平时无法排序的类型去指定标准，我们都知道字典是无序的，也没有什么标准，那么我们就来以字典的value作为排序的标准；</p>
<pre><code class="python">print(sorted(dict1, key=lambda x:x[1]))
#当然我们也可以选择key做为排序的标准
print(sorted(dict2, key=lambda x:int(x[0])))
</code></pre>
<p>由此可见高阶函数的抽象能力还是很强大的。</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>高阶函数出了可以接受对象作为参数之外还可以将函数作为结果值返回，当我们并不需要一个函数立刻执行的时候，就可以使用返回函数，比如我们在做累加的时候，不需要立刻去算出加法的值：</p>
<pre><code class="python">def lazy_sum(*argv):
  def sum():
    ax = 0
    for n in args:
      ax += n
      return ax
  return sum
</code></pre>
<p>那么在这个函数执行的时候，返回的就是一个函数对象，而不是执行了求和之后的结果，只有调用了<code>f()</code>之后才是真正计算求和的结果。这里还要提到一个概念就是闭包，学过javascript的同学可能会知道闭包的概念。所谓闭包，就是将<strong>组成函数的语句</strong>和这些语句的<strong>执行环境</strong>打包在一起时，得到的对象，也就是像上面的程序中<code>sum()</code>函数调用了外部函数的变量并处理了之后最后将这些整体作为一个函数对象返回值，这个就叫做闭包。</p>
<p>有一点需要注意的就是一个函数返回了另一个函数之后，内部的局部变量还在背新函数引用，所以闭包实现其实并不简单</p>
<pre><code class="python">def count():
  fs = []
  for i in range(1, 4):
    def f():
      return i*i
    fs.append(f)
  return fs

f1, f2, f3 = count()
</code></pre>
<p>正常而言我们可能会觉得调用上面的三个函数之后打印的结果应该是1, 4, 9，但是实际打印的结果全是9，原因就是因为返回的函数引用了变量<code>i</code>，等到i最后返回的时候它的值已经是3了，所以最终的执行结果全都是9。所以在闭包的时候一定要记住的一点就是返回函数不要引用任何的循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要使用循环变量的话，方法就是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre><code class="python">def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()
    return fs
</code></pre>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>在之前的demo中我们频繁的用到了lambda表达式，这个在python中被称作匿名函数，但是python对于匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数，这个限制就表现在匿名函数只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。然后就说一下装饰器。</p>
<p>那么什么叫做装饰器呢？在面向对象编程中我们有一个概念叫做装饰器模式，如果有了解过再去理解python中的装饰器就会比较容易了，OOP的装饰模式需要通过继承和组合来实现，python除了支持oop的装饰器还可以从语法层次上去支持。首先我们要知道python中一切皆为对象，那么函数也是一个对象，而且函数对象可以被赋值给变量，所以通过变量也能调用该函数。</p>
<pre><code class="python">&gt;&gt;&gt;def now:
...  print(&#39;hello&#39;)
...
&gt;&gt;&gt;f = now
&gt;&gt;&gt;f()
hello
</code></pre>
<p>函数对象有一个<code>__name__</code>属性，可以获取函数的名字，如果我们现在要增加一下这个函数的功能，但是又不想重新修改函数的定义，这种在代码的运行期间动态增加功能的方式就称作装饰器。</p>
<pre><code class="python">def log(func):
  def wrapper(*argv, **kw):
    print(&#39;call %s()&#39; % func.__name__)
    return func(*argv, **kw)
  return wrapper

#@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作 
@log
def now():
  print(&#39;hello&#39;)
</code></pre>
<p>那么这样的话我们就达到了在函数中添加打印日志的功能了，可能到这里还是有很多人并不知道装饰器到底有什么用，这里举个简单的例子，如果有很多函数都有打印日志的需求，在每个函数中都写一个，这样就会造成大量雷同的代码，装饰器是解决这类问题的绝佳设计，而且我们可以看到函数中可以传入任意的参数。</p>
<p>上面那个只是没有带参数的装饰器，其实我们可以理解为一个含有参数的闭包</p>
<pre><code class="python">def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
@log(&#39;execute&#39;)
def now():
  print(&#39;hello&#39;)
</code></pre>
<p>这样我们就可以给装饰器也传入参数，但是这样还是差一步，因为我们说过函数也是一个对象，因为返回的那个<code>wrapper()</code>函数名字就是<code>wrapper</code>，所以还需要把原始函数的属性复制过去，不然某些依赖函数签名执行的代码就会出错。但是我们不需要手动进行<code>wrapper.__name__ = func.__name__</code>这样的代码，python的内置函数就可以干这个事情了，所以一个完整的<code>decorator</code>应该是这个样子的：</p>
<pre><code class="python">import functools

def log():
  @functools.wrap(func)
  def wrapper(*argv, **kw):
    print(&#39;%s s():&#39; % (text, func.__name__))
    return func(*argv, **kw)
  return wrapper


#如果是带参数的就是这样
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
</code></pre>
<p>虽然装饰器的语法有些麻烦，但用起来却十分的灵活方便，如果有之后学习<code>flask</code>框架的，就会经常用到这种模式了。</p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>当我们觉得函数的参数太多的时候，是否觉得过于繁琐，但是有些参数有些情况需要，有些情况不需要，所以使用缺省参数也是不太合理的，于是我们从python的<code>functools</code>模块中找到了一个非常好用的功能，那就是偏函数，我们可以通过设定参数的默认值，可以降低函数调用的难度：</p>
<pre><code class="python">#int()函数默认按十进制转换
&gt;&gt;&gt; int(&#39;123456&#39;)
123456
</code></pre>
<p>但<code>int()函数</code>还提供了额外的参数，可以做到N进制的转换，那么如果我们有个要求是做二进制的转换的时候，每次都多加一个参数显然是没有必要的，所以就可以使用偏函数去固定这个参数：</p>
<pre><code class="python">&gt;&gt;&gt; import functools
&gt;&gt;&gt; int2 = functools.partial(int, base=2)
&gt;&gt;&gt; int2(&#39;1000000&#39;)
64
&gt;&gt;&gt; int2(&#39;1010101&#39;)
85
</code></pre>
<p>实际创建偏函数的时候，我们可以接受函数对象，<code>*argv</code>,<code>**kw</code>这三个参数，当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>


<!--<a href="http://yoursite.com/2017/11/06/Python-函数式编程/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>