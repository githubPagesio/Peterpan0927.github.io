<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Python-函数式编程 | Peterpan&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="当看到函数式编程的语法的时候就感觉自己被深深的吸引了，这是养成函数式编程范式的第一步。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-函数式编程">
<meta property="og:url" content="http://yoursite.com/2017/11/06/Python-函数式编程/index.html">
<meta property="og:site_name" content="Peterpan's Blog">
<meta property="og:description" content="当看到函数式编程的语法的时候就感觉自己被深深的吸引了，这是养成函数式编程范式的第一步。">
<meta property="og:updated_time" content="2018-03-02T12:56:44.847Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python-函数式编程">
<meta name="twitter:description" content="当看到函数式编程的语法的时候就感觉自己被深深的吸引了，这是养成函数式编程范式的第一步。">
  
    <link rel="alternate" href="/atom.xml" title="Peterpan&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/p1.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%8811.42.23.png">
    <h2 class="author">Peter pan</h2>
    <h3 class="description">the mark of an educated mind is to be able to entertain a thought without accepting it</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>97</strong><br>文章</div></a>
      <a href="/categories"><div><strong>89</strong><br>分类</div></a>
      <a href="/tags"><div><strong>14</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-Python-函数式编程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/06/Python-函数式编程/" class="article-date">
  <time class="post-time" datetime="2017-11-06T15:36:28.000Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">06</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python-函数式编程
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/函数式编程/">函数式编程</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当看到函数式编程的语法的时候就感觉自己被深深的吸引了，这是养成函数式编程范式的第一步。</p>
<a id="more"></a>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>也许继面向对象之后，函数式编程会成为下一个主流的编程范式，其实与其在语言中说这个不如说是函数式编程的思想。首先函数式编程的代码非常容易理解，偏向自然语言，而且函数式编程不依赖也不会改变外界的状态。因此每一个函数都可以看作独立单元，这样有利于模块化组合。</p>
<p>其次它有利于并发编程，我们不需要去考虑死锁的问题，因为它根本不会修改变量，所以我们可以很放心的把任务分摊到多个线程，部署并发编程。</p>
<h2 id="mapreduce"><a class="markdownIt-Anchor" href="#mapreduce"></a> map/reduce</h2>
<p>显然map/reduce是函数式编程中非常经典的部分了，首先看看map，<code>map()</code>函数接受两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用于序列中的每一个元素，并把结果作为新的<code>Iterator</code>返回（Python3中是这样，而在python2中返回的仍然是一个<code>Interable</code>）.下面举个例子</p>
<pre class="highlight"><code class="python">&gt;&gt;&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span>:</span>
...		<span class="hljs-keyword">return</span> x
...
&gt;&gt;&gt;r = map(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])
&gt;&gt;&gt;list(r)
[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]
</code></pre>
<p>这里因为<code>map()</code>返回的是一个<code>Interator</code>，<code>Interator</code>是一个惰性序列，因此通过<code>list()</code>函数计算出整个序列返回。虽然这个我们使用for循环同样可以做到，但是无法一眼看出来目的，而且代码冗长。</p>
<p>所以,<code>map()</code>作为高阶函数，事实上他把运算规则抽象了，我们除了计算上面的之外还可以计算任意复杂的函数，如：</p>
<pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>list(map(str, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))
[<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>, <span class="hljs-string">'6'</span>, <span class="hljs-string">'7'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'9'</span>]
</code></pre>
<p>再看<code>reduce</code>的用法。<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
<pre class="highlight"><code class="python">&gt;&gt;&gt;<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce
&gt;&gt;&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y)</span>:</span>
...		<span class="hljs-keyword">return</span> x+y
...
&gt;&gt;&gt;reduce(add, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])
<span class="hljs-number">25</span>
</code></pre>
<p>因为python中已经有<code>sum()</code>内置函数做加法了，如果这个时候要将上面的列表变成<code>13579</code>，reduce就可以派上用场了</p>
<pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span><span class="hljs-params">(x, y)</span>:</span>
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y
...
<span class="hljs-meta">&gt;&gt;&gt; </span>reduce(fn, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>])
<span class="hljs-number">13579</span>
</code></pre>
<p>这个例子本身没有多大用，如果考虑到字符串也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，就可以自己手写一个<code>str</code>转<code>int</code>了，这里先提前使用一下lambda函数：</p>
<pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce

keys = [str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>)]
values = range(<span class="hljs-number">9</span>)
the_dict = dict(zip(keys, values))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char2num</span><span class="hljs-params">(s)</span>:</span>
	<span class="hljs-keyword">return</span> the_dict[s]
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str2int</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x * <span class="hljs-number">10</span> + y, map(char2num, s))
</code></pre>
<p>这样就算不掉用python的<code>int()</code>函数也可以自己写一个将字符串转换成整数的函数，下面就来做几个练习来巩固一下；</p>
<ol>
<li>利用<code>map()</code>函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：<code>['adam', 'LISA', 'barT']</code>，输出：<code>['Adam', 'Lisa', 'Bart']</code>：</li>
</ol>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalize</span><span class="hljs-params">(name)</span>:</span>
    <span class="hljs-keyword">return</span> name[<span class="hljs-number">0</span>].upper()+name[<span class="hljs-number">1</span>:].lower()
L1 = [<span class="hljs-string">'adam'</span>, <span class="hljs-string">'LISA'</span>, <span class="hljs-string">'barT'</span>]
L2 = list(map(normalize, L1))
print(L2)
</code></pre>
<ol start="2">
<li>Python的<code>sum()</code>函数可以接受一个list并求和，编写一个<code>prod()</code>函数，可以接受一个list并利用reduce()求积：</li>
</ol>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">prod</span><span class="hljs-params">(L)</span>:</span>
    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, L)
</code></pre>
<ol start="3">
<li>利用<code>map</code>和<code>reduce</code>编写一个<code>str2float</code>函数，把字符串<code>'123.456'</code>转换成浮点数<code>123.456</code>：</li>
</ol>
<pre class="highlight"><code class="python"><span class="hljs-comment">#-*- coding:utf-8 -*-</span>
<span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> division <span class="hljs-comment">#兼容python2</span>
<span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str2int</span><span class="hljs-params">(s)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char2num</span><span class="hljs-params">(c)</span>:</span>
        <span class="hljs-keyword">return</span> {<span class="hljs-string">'0'</span>: <span class="hljs-number">0</span>, <span class="hljs-string">'1'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'2'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'3'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'4'</span>: <span class="hljs-number">4</span>, <span class="hljs-string">'5'</span>: <span class="hljs-number">5</span>,<span class="hljs-string">'6'</span>: <span class="hljs-number">6</span>, <span class="hljs-string">'7'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'8'</span>: <span class="hljs-number">8</span>, <span class="hljs-string">'9'</span>: <span class="hljs-number">9</span>}[c]
    <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x *<span class="hljs-number">10</span> + y, map(char2num, s))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str2float</span><span class="hljs-params">(s)</span>:</span>
    s_list = s.split(<span class="hljs-string">'.'</span>)            
    float_i = str2int(s_list[<span class="hljs-number">0</span>])     
    float_f = <span class="hljs-number">0.1</span>
    float_f = str2int(s_list[<span class="hljs-number">1</span>]) / (<span class="hljs-number">10</span>**len(s_list[<span class="hljs-number">1</span>]))
    <span class="hljs-keyword">return</span> float_i + float_f

print(str2float(<span class="hljs-string">'123.456'</span>))
</code></pre>
<h2 id="filtersorted"><a class="markdownIt-Anchor" href="#filtersorted"></a> filter/sorted</h2>
<p>python内建的<code>filter()</code>函数用于过滤序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每一个元素，然后跟据返回的值是True还是False决定保留还是丢弃该元素。下面举几个例子：</p>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_ord</span><span class="hljs-params">()</span>:</span>
  <span class="hljs-keyword">return</span> n %<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>
list(filter(is_ord, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]))
<span class="hljs-comment"># 结果: [1, 5, 9, 15]</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">not_empty</span><span class="hljs-params">(n)</span>:</span>
  <span class="hljs-keyword">return</span> s <span class="hljs-keyword">and</span> s.strip()
list(filter(not_empty, [<span class="hljs-string">'A'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'B'</span>, <span class="hljs-keyword">None</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'  '</span>]))
<span class="hljs-comment"># 结果: ['A', 'B', 'C']</span>
</code></pre>
<p>我们可见<code>filter()</code>旨在做筛选，和<code>map()</code>一样，它返回的也是一个<code>Iterator</code>，也就是一个惰性序列，我们可以利用filter实现一个计算素数的方法—埃氏筛法：</p>
<pre class="highlight"><code class="python"><span class="hljs-comment">#首先构造一个从3开始的奇数序列</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_odd_iter</span><span class="hljs-params">()</span>:</span>
  	n = <span class="hljs-number">1</span>
  	<span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
  		n = n + <span class="hljs-number">2</span>
        <span class="hljs-keyword">yield</span> n
<span class="hljs-comment">#定义一个筛选函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_not_divisible</span><span class="hljs-params">(n)</span>:</span>
  	<span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x: x % n &gt; <span class="hljs-number">0</span>
<span class="hljs-comment">#定义一个生成器，不断返回下一个素数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">primes</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>
    it = _odd_iter() <span class="hljs-comment"># 初始序列</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">True</span>:
        n = next(it) <span class="hljs-comment"># 返回序列的第一个数</span>
        <span class="hljs-keyword">yield</span> n
        it = filter(_not_divisible(n), it) <span class="hljs-comment"># 构造新序列</span>
<span class="hljs-comment">#设置调用条件，打印1000以内的素数:</span>
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> primes():
    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1000</span>:
        print(n)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">break</span>
</code></pre>
<p>我们都知道在C语言中有一个练习是判断一个字符串是不是回文串，那么使用python的<code>filter()</code>去实现的话就很简单了</p>
<pre class="highlight"><code class="python">L = [<span class="hljs-number">12321</span>, <span class="hljs-number">565</span>, <span class="hljs-number">2222</span>,<span class="hljs-number">34343</span>]
print(filter(<span class="hljs-keyword">lambda</span>: x == int(str(x)[::<span class="hljs-number">-1</span>], L)))
</code></pre>
<p>同时排序也是程序中会经常用到的算法，但是有时候我们需要根据我们的需求进行不同衡量标准的排序，这个时候我们就可以使用python中名为<code>sorted()</code>的高阶函数，这个函数中有一参数是key，我们可以根据需要传入排序衡量的标准，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过<code>key=abs</code>处理过的list，也许你觉得这样说有点抽象，那么我们就来举个例子：</p>
<pre class="highlight"><code class="python"><span class="hljs-comment">#正常数字排序是从小到大</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sorted([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-21</span>])
[<span class="hljs-number">-21</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">36</span>]
<span class="hljs-comment">#但是我们可以选择按照绝对值去排序</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sorted([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-21</span>], key=abs)
<span class="hljs-comment">#如果需要反向排序，只需要添加第三个参数</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>sorted([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-21</span>], key=abs, reverse=<span class="hljs-keyword">True</span>)
</code></pre>
<p>也许你会说这似乎也没什么了不起的，还是在排序罢了，那么接下来就介绍一下如果给我们平时无法排序的类型去指定标准，我们都知道字典是无序的，也没有什么标准，那么我们就来以字典的value作为排序的标准；</p>
<pre class="highlight"><code class="python">print(sorted(dict1, key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>]))
<span class="hljs-comment">#当然我们也可以选择key做为排序的标准</span>
print(sorted(dict2, key=<span class="hljs-keyword">lambda</span> x:int(x[<span class="hljs-number">0</span>])))
</code></pre>
<p>由此可见高阶函数的抽象能力还是很强大的。</p>
<h2 id="返回函数"><a class="markdownIt-Anchor" href="#返回函数"></a> 返回函数</h2>
<p>高阶函数出了可以接受对象作为参数之外还可以将函数作为结果值返回，当我们并不需要一个函数立刻执行的时候，就可以使用返回函数，比如我们在做累加的时候，不需要立刻去算出加法的值：</p>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy_sum</span><span class="hljs-params">(*argv)</span>:</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span>:</span>
    ax = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args:
      ax += n
      <span class="hljs-keyword">return</span> ax
  <span class="hljs-keyword">return</span> sum
</code></pre>
<p>那么在这个函数执行的时候，返回的就是一个函数对象，而不是执行了求和之后的结果，只有调用了<code>f()</code>之后才是真正计算求和的结果。这里还要提到一个概念就是闭包，学过javascript的同学可能会知道闭包的概念。所谓闭包，就是将<strong>组成函数的语句</strong>和这些语句的<strong>执行环境</strong>打包在一起时，得到的对象，也就是像上面的程序中<code>sum()</code>函数调用了外部函数的变量并处理了之后最后将这些整体作为一个函数对象返回值，这个就叫做闭包。</p>
<p>有一点需要注意的就是一个函数返回了另一个函数之后，内部的局部变量还在背新函数引用，所以闭包实现其实并不简单</p>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>:</span>
  fs = []
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span>
      <span class="hljs-keyword">return</span> i*i
    fs.append(f)
  <span class="hljs-keyword">return</span> fs

f1, f2, f3 = count()
</code></pre>
<p>正常而言我们可能会觉得调用上面的三个函数之后打印的结果应该是1, 4, 9，但是实际打印的结果全是9，原因就是因为返回的函数引用了变量<code>i</code>，等到i最后返回的时候它的值已经是3了，所以最终的执行结果全都是9。所以在闭包的时候一定要记住的一点就是返回函数不要引用任何的循环变量，或者后续会发生变化的变量。</p>
<p>如果一定要使用循环变量的话，方法就是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(j)</span>:</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-params">()</span>:</span>
            <span class="hljs-keyword">return</span> j*j
        <span class="hljs-keyword">return</span> g
    fs = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):
        fs.append(f(i)) <span class="hljs-comment"># f(i)立刻被执行，因此i的当前值被传入f()</span>
    <span class="hljs-keyword">return</span> fs
</code></pre>
<h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2>
<p>在之前的demo中我们频繁的用到了lambda表达式，这个在python中被称作匿名函数，但是python对于匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数，这个限制就表现在匿名函数只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。然后就说一下装饰器。</p>
<p>那么什么叫做装饰器呢？在面向对象编程中我们有一个概念叫做装饰器模式，如果有了解过再去理解python中的装饰器就会比较容易了，OOP的装饰模式需要通过继承和组合来实现，python除了支持oop的装饰器还可以从语法层次上去支持。首先我们要知道python中一切皆为对象，那么函数也是一个对象，而且函数对象可以被赋值给变量，所以通过变量也能调用该函数。</p>
<pre class="highlight"><code class="python">&gt;&gt;&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span>:</span>
<span class="hljs-meta">... </span> print(<span class="hljs-string">'hello'</span>)
...
&gt;&gt;&gt;f = now
&gt;&gt;&gt;f()
hello
</code></pre>
<p>函数对象有一个<code>__name__</code>属性，可以获取函数的名字，如果我们现在要增加一下这个函数的功能，但是又不想重新修改函数的定义，这种在代码的运行期间动态增加功能的方式就称作装饰器。</p>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(func)</span>:</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*argv, **kw)</span>:</span>
    print(<span class="hljs-string">'call %s()'</span> % func.__name__)
    <span class="hljs-keyword">return</span> func(*argv, **kw)
  <span class="hljs-keyword">return</span> wrapper

<span class="hljs-comment">#@符号是装饰器的语法糖，在定义函数的时候使用，避免再一次赋值操作 </span>
<span class="hljs-meta">@log</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span><span class="hljs-params">()</span>:</span>
  print(<span class="hljs-string">'hello'</span>)
</code></pre>
<p>那么这样的话我们就达到了在函数中添加打印日志的功能了，可能到这里还是有很多人并不知道装饰器到底有什么用，这里举个简单的例子，如果有很多函数都有打印日志的需求，在每个函数中都写一个，这样就会造成大量雷同的代码，装饰器是解决这类问题的绝佳设计，而且我们可以看到函数中可以传入任意的参数。</p>
<p>上面那个只是没有带参数的装饰器，其实我们可以理解为一个含有参数的闭包</p>
<pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(text)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span><span class="hljs-params">(func)</span>:</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kw)</span>:</span>
            print(<span class="hljs-string">'%s %s():'</span> % (text, func.__name__))
            <span class="hljs-keyword">return</span> func(*args, **kw)
        <span class="hljs-keyword">return</span> wrapper
    <span class="hljs-keyword">return</span> decorator
<span class="hljs-meta">@log('execute')</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">now</span><span class="hljs-params">()</span>:</span>
  print(<span class="hljs-string">'hello'</span>)
</code></pre>
<p>这样我们就可以给装饰器也传入参数，但是这样还是差一步，因为我们说过函数也是一个对象，因为返回的那个<code>wrapper()</code>函数名字就是<code>wrapper</code>，所以还需要把原始函数的属性复制过去，不然某些依赖函数签名执行的代码就会出错。但是我们不需要手动进行<code>wrapper.__name__ = func.__name__</code>这样的代码，python的内置函数就可以干这个事情了，所以一个完整的<code>decorator</code>应该是这个样子的：</p>
<pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> functools

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">()</span>:</span>
<span class="hljs-meta">  @functools.wrap(func)</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*argv, **kw)</span>:</span>
    print(<span class="hljs-string">'%s s():'</span> % (text, func.__name__))
    <span class="hljs-keyword">return</span> func(*argv, **kw)
  <span class="hljs-keyword">return</span> wrapper


<span class="hljs-comment">#如果是带参数的就是这样</span>
<span class="hljs-keyword">import</span> functools

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(text)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span><span class="hljs-params">(func)</span>:</span>
<span class="hljs-meta">        @functools.wraps(func)</span>
        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kw)</span>:</span>
            print(<span class="hljs-string">'%s %s():'</span> % (text, func.__name__))
            <span class="hljs-keyword">return</span> func(*args, **kw)
        <span class="hljs-keyword">return</span> wrapper
    <span class="hljs-keyword">return</span> decorator
</code></pre>
<p>虽然装饰器的语法有些麻烦，但用起来却十分的灵活方便，如果有之后学习<code>flask</code>框架的，就会经常用到这种模式了。</p>
<h2 id="偏函数"><a class="markdownIt-Anchor" href="#偏函数"></a> 偏函数</h2>
<p>当我们觉得函数的参数太多的时候，是否觉得过于繁琐，但是有些参数有些情况需要，有些情况不需要，所以使用缺省参数也是不太合理的，于是我们从python的<code>functools</code>模块中找到了一个非常好用的功能，那就是偏函数，我们可以通过设定参数的默认值，可以降低函数调用的难度：</p>
<pre class="highlight"><code class="python"><span class="hljs-comment">#int()函数默认按十进制转换</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>int(<span class="hljs-string">'123456'</span>)
<span class="hljs-number">123456</span>
</code></pre>
<p>但<code>int()函数</code>还提供了额外的参数，可以做到N进制的转换，那么如果我们有个要求是做二进制的转换的时候，每次都多加一个参数显然是没有必要的，所以就可以使用偏函数去固定这个参数：</p>
<pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> functools
<span class="hljs-meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="hljs-number">2</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>int2(<span class="hljs-string">'1000000'</span>)
<span class="hljs-number">64</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>int2(<span class="hljs-string">'1010101'</span>)
<span class="hljs-number">85</span>
</code></pre>
<p>实际创建偏函数的时候，我们可以接受函数对象，<code>*argv</code>,<code>**kw</code>这三个参数，当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/06/Python-函数式编程/" data-id="cjg9k0mdf002y9fbr0l11bos0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/14/iOS多线程之NSOperation/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          iOS多线程之NSOperation
        
      </div>
    </a>
  
  
    <a href="/2017/11/05/iOS第三方和权限问题/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">iOS第三方和权限问题</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Peterpan&#39;s Blog</h1>
    <h2 class="blog-subtitle">Mind over muscle.</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%8811.42.23.png">
    <h2 class="author">Peter pan</h2>
    <h3 class="description">the mark of an educated mind is to be able to entertain a thought without accepting it</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>97</strong><br>文章</div></a>
      <a href="/categories"><div><strong>89</strong><br>分类</div></a>
      <a href="/tags"><div><strong>14</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/Peterpan0927" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="https://www.imbajin.com" target="_blank" title="Jin">
          Jin
        </a>
      
        <a class="hvr-bounce-in" href="https://yinwang0.wordpress.com" target="_blank" title="Yinwang(English)">
          Yinwang(English)
        </a>
      
        <a class="hvr-bounce-in" href="http://www.yinwang.org" target="_blank" title="Yinwang(Chinese)">
          Yinwang(Chinese)
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 Peter pan<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/about" title="" class="menuItem">音乐</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="https://github.com/Peterpan0927" title="" class="menuItem">Github</a>
          
            <a href="ftp://118.89.38.168" title="" class="menuItem">FTP</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>



  </div>
</body>
</html>