<html>
<head>
	
	<title>iOS网络部分(一)</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">iOS网络部分(一)</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2017年12月8日


    <a class="article-category-link" href="/categories/断点续传-App内置浏览器/">断点续传 App内置浏览器</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#NSURLConnection和NSURLSession"><span class="toc-text">NSURLConnection和NSURLSession</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用现状"><span class="toc-text">使用现状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上传和下载"><span class="toc-text">上传和下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#断点续传"><span class="toc-text">断点续传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置信息"><span class="toc-text">配置信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对于断点续传的处理"><span class="toc-text">对于断点续传的处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于UIWebView"><span class="toc-text">关于UIWebView</span></a></li></ol>
<p>在学习逆向的过程中又延伸到了OC的runtime机制，也就是OC的灵魂所在，然后就莫名延伸到网络请求部分了，考虑到之前做项目原生写的网络请求+多线程也有些问题，所以还是总结一下吧</p>
<a id="more"></a>
<h2 id="NSURLConnection和NSURLSession"><a href="#NSURLConnection和NSURLSession" class="headerlink" title="NSURLConnection和NSURLSession"></a>NSURLConnection和NSURLSession</h2><h3 id="使用现状"><a href="#使用现状" class="headerlink" title="使用现状"></a>使用现状</h3><p>可以说NSURLSession是前者的替代了，早在13年的WWDC就和iOS7一起发布了，是对NSURLConnection进行了重构优化后新的网络访问接口。从iOS9.0开始，NSURLConnection中发送请求的两个方法就已经过期了，初始化网络连接的方法就是，就好比原来的UIAlertView和现在的UIActionController的关系差不多。</p>
<h3 id="上传和下载"><a href="#上传和下载" class="headerlink" title="上传和下载"></a>上传和下载</h3><p>NSURLSession针对上传和下载等复杂的网络操作提供了专门的解决方案，根据需求的不同分别对应了三种不同的网络请求任务。创建的task都是挂起状态，需要resume才能执行。</p>
<p>当服务器返回的数据比较小的时候，两者执行普通任务的操作步骤并没有什么区别，执行上传任务的以后，如果是post都需要设置请求体。在这里还体现不出来为什么Apple会放弃前者，那么我们再来看看下载的部分好了：</p>
<p>前者在下载文件的时候，首先会将整个文件下载到内存中去，然后再写入沙盒，那么这就意味着如果一个文件再过大的时候就会出现内存暴涨的情况，而后者会默认下载到沙盒路径下的tmp文件夹，下载完成之后再将临时文件删除，如果还需要保存的话可以在回调方法中写明：</p>
<pre><code class="objective-c">NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@&quot;http://127.0.0.1/dawenjian.zip&quot;] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
   //获取沙盒的caches路径
   NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;kkk.dmg&quot;];

   //生成URL路径
   NSURL *DCurl = [NSURL fileURLWithPath:path];

   //将文件保存到指定文件目录下
   [[NSFileManager defaultManager]moveItemAtURL:location toURL:DCurl error:nil];   }];
[task resume];
</code></pre>
<p>还有一点就是后者在请求方式上要更加灵活一些，因为前者从实例化开始就会发送请求，可以cancel掉，但是后者还拥有着暂停和恢复方法，相较更加优化。</p>
<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>NSURLConnection进行断点下载，通过设置访问请求的HTTPHeaderField的Range属性，开启运行循环，NSURLConnection的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用NSOutputStream管道流进行数据保存。</p>
<p>NSURLSession进行断点下载，当暂停下载任务后，如果 downloadTask （下载任务）为非空，调用 </p>
<pre><code class="objective-c">cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler
</code></pre>
<p> 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中。在点击再次下载时，通过调用 </p>
<pre><code class="objective-c">[[self.session downloadTaskWithResumeData:self.resumeData]resume]
</code></pre>
<p>方法进行继续下载操作。 经过以上比较可以发现，使用NSURLSession进行断点下载更加便捷。</p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>NSURLSession的构造方法 （sessionWithConfiguration:delegate:delegateQueue）中有一个 NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比于 NSURLConnection 依赖于一个全局的配置对象，缺乏灵活性而言，NSURLSession 有很大的改进了。NSURLSession可以设置三种配置信息，分别通过调用三个类方法返回配置对象：</p>
<pre><code class="objective-c">+ (NSURLSessionConfiguration *)defaultSessionConfiguration
  //配置信息使用基于硬盘的持久化Cache，保存用户的证书到钥匙串,使用共享cookie存储；
+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration 
  //配置信息和default大致相同。除了，不会把cache，证书，或者任何和Session相关的数据存储到硬盘，而是存储在内存中，生命周期和Session一致。比如浏览器无痕浏览等功能就可以基于这个来做；
 + (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier
  //配置信息可以创建一个可以在后台甚至APP已经关闭的时候仍然在传输数据的session。注意，后台Session一定要在创建的时候赋予一个唯一的identifier，这样在APP下次运行的时候，能够根据identifier来进行相关的区分。如果用户关闭了APP,IOS 系统会关闭所有的background Session。而且，被用户强制关闭了以后，IOS系统不会主动唤醒APP，只有用户下次启动了APP，数据传输才会继续。
</code></pre>
<p>当然虽然NSURLSession已经比较优化了，但是要灵活的使用其代理方法才能将其性能给发挥出来，比如说SDWebImage中的下载方法中有一个回调可以打印下载的进度调用的就是<code>NSURLSessionDownloadDelegate</code>的代理方法。如果阅读一下这种框架的源码对于我们程序能力的提升也是比较大的。同时原生的做文件的上传下载的时候推荐使用配置信息，最好是写在session的懒加载之中。</p>
<p>·</p>
<h2 id="对于断点续传的处理"><a href="#对于断点续传的处理" class="headerlink" title="对于断点续传的处理"></a>对于断点续传的处理</h2><p>这种功能在业务中其实是很常见的，很多时候我们需要暂停，过一段时间再继续下载，或者由于某种情况断了网，希望恢复之后可以紧接着原来的进度，如果下游戏的时候不小心关机了，如果没有这样的处理，估计玩家们都会急得跳脚了。那么回归正题，主要的模块就是下面几个：</p>
<pre><code class="objective-c">- (IBAction)startBtnClick:(id)sender{
  NSURL *url = [NSURL URLWithString:@&quot;http://127.0.0.1/resources/1.zip&quot;];
  //创建请求对象
  NSURLRequest *request = [NSURLRequest requestWithURL:url];
  //创建session
  self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];
  //创建Task
  NSURLSessionDownloadTask *downloadTask = [self.session downloadTaskWithRequest:request];
  self.downloadTask = downloadTask;
  //执行Task
  [self.downloadTask resume];
}

//暂停部分
- (IBAction)suspendBtnClick:(id)sender{
  [self.downloadTask suspend];
}

//取消部分
- (IBAction)cancelBtnClick:(id)sender{
  [self.downloadTask cancel];
}

//继续下载部分
- (IBAction)goOnBtnClick:(id)sender{
  [self.downloadTask resume];
}
</code></pre>
<p>看起来应该是很简单的，但这只是一个最简陋版而已，下面就有一点注意了，那就是在cancel之后任务是无法恢复的，如果想要取消之后恢复的话就要获得之前的下载数据并重新开启一个下载的任务：</p>
<pre><code class="objective-c">//恢复下载的数据不等于文件数据，而是类似于元数据，只是记录位置、时间
[self.downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData){
  self.resumeData = resumeData;
}];

//于此同时继续下载方法也需要迭代
- (IBAction)goOnBtnClick:(id)sender{
  if(self.resumeData){
    self.downloadTask = [self.session downloadTaskWithResumeData:self.resumeData];
  }
  [self.downloadTask resume];
}
</code></pre>
<p>那么经过这一次的迭代之后我们就可以避免用户误点而造成的流量损耗，接下来想想还有什么可以去优化的地方，如果用户不小心退出了呢？那么点开始下载岂不是又会重新下载，虽然现在的iOS多任务后台已经完善了很多，但这个时候我们依旧不可能再通过控制器中的属性再做判断了，显然要利用一个不会随着控制器生命周期结束的东西作为我们的判断标准，没错，那就是沙盒缓存，这里我们需要用到文件句柄:</p>
<pre><code class="objective-c">//首先要在得到response的代理方法中创建文件句柄和空文件
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{
     self.totalSize = response.expectedContentLength; 

    self.fullPath = [[NSSearchPathForDirectoryInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename];

    //创建空文件
    [[NSFileManager defaultManager] createFileAtPath:fullPath contents:nil         attributes:nil];

    //创建文件句柄，其实句柄的英文名就是File handle，也就是控制file的东西，只不过翻译后会让人不明所以
    self.handle = [NSFileHandle fileHandleForWritingAtPath:fullPath];
    completionHandler(NSURLSessionResponseAllow);  

}

//得知下载的过程,根据进度条直观的显示
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{
      //从文件尾部添加数据，这里会自动向尾部追加，不需要人为再去移动指针
      [self.handle writeData:data];
    self.currentSize += data.length;
      NSLog(@&quot;%f&quot;, 1.0 * self.currentSize/self.totalSize);
      self.progressView.progress = 1.0 * self.currentSize/self.totalSize;
}


//最后在下载完成之后关闭文件，并将指针置空
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{
    [self.handle closeFile];
    self.handle = nil;
}
</code></pre>
<p>到这里的时候还有什么可以继续优化的呢，我们发现只有start方法的代码是最长的，而且每次都会重新创建一个任务，所以自然而然地想到了去懒加载，那么取消方法此刻如果将任务的指针置空的话，就不需要再进行if判断，直接会通过懒加载重新创建一个网络请求，还可以根据已经请求的数据大小去告诉服务器请求那一部分数据：</p>
<pre><code class="objective-c">- (NSURLSessionDataTask *)dataTask{
      if(_dataTask == nil){
            NSURL *url = [NSURL URLWithString:@&quot;http://127.0.0.1/resources/1.zip&quot;];
        //创建请求对象
         NSMutableURLRequest *request = [NSURLRequest requestWithURL:url];
        NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;, self.currentSize];
        //告诉服务器请求哪一部分的数据
        [request setValue:range forHTTPHeaderField:@&quot;Range&quot;]
          //创建session
          self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];
        //创建Task
          _dataTask = [self.session downloadTaskWithRequest:request];
      }
      return _dataTask;
}

//开始部分
- (IBAction)startBtnClick:(id)sender{
  [self.dataTask resume];
}
//暂停部分
- (IBAction)suspendBtnClick:(id)sender{
  [self.dataTask suspend];
}

//取消部分
- (IBAction)cancelBtnClick:(id)sender{
  [self.dataTask cancel];
  self.dataTask = nil;
}

//继续下载部分
- (IBAction)goOnBtnClick:(id)sender{
  [self.dataTask resume];
}
</code></pre>
<p>但是这个时候我们会发现打印的下载进度不太对，如果我们经过了一次取消之后再下载，进度条满了之后仍然在跑，下载的进度也会超过一，那么这又是为什么呢？</p>
<pre><code class="objective-c">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{
     //这个expectedContentLength是本次请求的数据大小，所以还需要加上已经下载的
      self.totalSize = response.expectedContentLength + self.currentSize;
    self.fullPath = [[NSSearchPathForDirectoryInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename];
      //而且如果是断点续传的话就已经拥有文件了，不需要再重新创造一个新的文件
      if(self.currentSize == 0){
        [[NSFileManager defaultManager] createFileAtPath:self.fullPath contents:nil         attributes:nil];
      }
      self.handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath];
      //移动文件句柄指针到末尾，添加数据
      [self.handle seekToEndOfFile];
    completionHandler(NSURLSessionResponseAllow);  
}
</code></pre>
<p>到这里的时候还没有做到真正的离线下载，也就是程序退出之后重新进也可以断点续传，现在已经完成做到了沙盒缓存，只需要再加一次开始下载之前的判断即可：</p>
<pre><code class="objective-c">- (NSURLSessionDataTask *)dataTask{
      if(_dataTask == nil){
            NSURL *url = [NSURL URLWithString:@&quot;http://127.0.0.1/resources/1.zip&quot;];
        //创建请求对象
         NSMutableURLRequest *request = [NSURLRequest requestWithURL:url];
          //获取之前下载的文件信息
          NSDictionary *fileInfoDict = [[NSFileManager defaultManager] attributesOfItemAtPath:self.fullPath];
          //将已经下载的大小赋值回去
          self.currentSize = [fileInfoDict[@&quot;NSFileSize&quot;] integerValue];
        NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;, self.currentSize];
        //告诉服务器请求哪一部分的数据
        [request setValue:range forHTTPHeaderField:@&quot;Range&quot;]
          //创建session
          self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];
        //创建Task
          _dataTask = [self.session downloadTaskWithRequest:request];
      }
      return _dataTask;
}
</code></pre>
<p>最后再总的贴出一份完整版的代码吧，也就是最后的最优化版本,并且进行了一些代码的抽取，使整体性更强:</p>
<pre><code class="objective-c">@interface ViewController()&lt;NSURLSessionDataDelegate&gt;

@property (nonatomic, strong) NSFileHandle *handle;
@property (nonatomic, strong) NSInteger totalSize;
@property (nonatomic, strong) NSInteger currentSize;
@property (nonatomic, strong) NSString *fullPath;
@property (nonatomic, strong) NSURLSessionDataTask *dataTask;
@property (nonatomic, strong) NSURLSession *session

@end

@implementation ViewController

//session懒加载
- (NSURLSession *)session{
  if(_session == nil){
    _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];
  }  
  return _session;
}

//fullPath懒加载
- (NSString *)fulPath{
  if(_fullPath == nil){
    _fullPath = [[NSSearchPathForDirectoryInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename];
  }
  return _fullPath;
}

- (NSInteger)getCurrentSize{
  //获取之前下载的文件信息
  NSDictionary *fileInfoDict = [[NSFileManager defaultManager] attributesOfItemAtPath:self.fullPath];
  return [fileInfoDict[@&quot;NSFileSize&quot;] integerValue];
}

- (NSURLSessionDataTask *)dataTask{
      if(_dataTask == nil){
            NSURL *url = [NSURL URLWithString:@&quot;http://127.0.0.1/resources/1.zip&quot;];
        //创建请求对象
         NSMutableURLRequest *request = [NSURLRequest requestWithURL:url];
          //将已经下载的大小赋值回去
          self.currentSize = [self getCurrentSize];
        NSString *range = [NSString stringWithFormat:@&quot;bytes=%zd-&quot;, self.currentSize];
        //告诉服务器请求哪一部分的数据
        [request setValue:range forHTTPHeaderField:@&quot;Range&quot;]
        //创建Task
          _dataTask = [self.session downloadTaskWithRequest:request];
      }
      return _dataTask;
}

//开始部分
- (IBAction)startBtnClick:(id)sender{
  [self.dataTask resume];
}
//暂停部分
- (IBAction)suspendBtnClick:(id)sender{
  [self.dataTask suspend];
}

//取消部分
- (IBAction)cancelBtnClick:(id)sender{
  [self.dataTask cancel];
  self.dataTask = nil;
}

//继续下载部分
- (IBAction)goOnBtnClick:(id)sender{
  [self.dataTask resume];
}

- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler{
     //这个expectedContentLength是本次请求的数据大小，所以还需要加上已经下载的
      self.totalSize = response.expectedContentLength + self.currentSize;
      //而且如果是断点续传的话就已经拥有文件了，不需要再重新创造一个新的文件
      if(self.currentSize == 0){
        [[NSFileManager defaultManager] createFileAtPath:self.fullPath contents:nil         attributes:nil];
      }
      self.handle = [NSFileHandle fileHandleForWritingAtPath:self.fullPath];
      //移动文件句柄指针到末尾，添加数据
      [self.handle seekToEndOfFile];
    completionHandler(NSURLSessionResponseAllow);  
}

//得知下载的过程,根据进度条直观的显示
- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data{
      //从文件尾部添加数据，这里会自动向尾部追加，不需要人为再去移动指针
      [self.handle writeData:data];
    self.currentSize += data.length;
      NSLog(@&quot;%f&quot;, 1.0 * self.currentSize/self.totalSize);
      self.progressView.progress = 1.0 * self.currentSize/self.totalSize;
}


//最后在下载完成之后关闭文件，并将指针置空
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error{
    [self.handle closeFile];
    self.handle = nil;
}
</code></pre>
<h2 id="关于UIWebView"><a href="#关于UIWebView" class="headerlink" title="关于UIWebView"></a>关于UIWebView</h2><p>UIWebView即使iOS内置的浏览器控件，系统自带的Safari就是通过UIWebView来实现的，它不仅可以加载远程的网页资源，还能加载绝大部分的常见文件，如html/pdf/ppt等，其实介绍一个类无非就是介绍它的常用属性方法和代理</p>
<p>首先就简单介绍一些常用的属性和方法:</p>
<pre><code class="objective-c">//比如我们现在想要要加一个百度的网页最简单的做法
- (void)viewDidLoad{
  [super viewDidLoad];
  NSURL *url = [NSURL URLWithString@&quot;http://www.baidu.com&quot;];
  //加载网页
  [self.webView loadRequest:[NSURLRequest requestWithURL:url]];
}
</code></pre>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-12-09%20%E4%B8%8B%E5%8D%881.56.03.png" alt=""></p>
<p>效果看起来还是挺唬人的，除了可以加载网页还可以加载图片、视频等，但是一个只包含这个的App显然是无法上架的，当然我们还需要进一步的操作并且得到响应，而且有时候前端的网页没有做自适应，也是需要我们自己调整的：</p>
<pre><code class="objective-c">//让界面自适应
self.webView.scalesPageToFit = YES;
//同时我们还可以加载本地文件的网页
NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.html&quot; withExtension:nil];
//页面前进
[self.webView goForward];
//页面后退
[self.webView goBack];
//页面刷新
[self.webView reload];
</code></pre>
<p>虽然这几个属性和方法比较简单，但是由于开发工程师还需要考虑到用户友好，所以还有进行一些优化：</p>
<pre><code class="objective-c">//这里就需要用到相关的代理方法了
- (void)webViewDidFinishLoad:(UIWebView *)webView{
      //在网页加载完毕之后判断当前的页面是否可以前进或者后退
    self.goBack.enabled = self.webView.canGoBack;
    self.goForward.enabled = self.webView.canGoForward;
}
</code></pre>
<p>和UIWebView进行交互，调用web页面中的需要传参的函数时，参数需要带单引号，或者双引号(双引号要进行转义在转义字符前加’\’),传递json字符串不需要加上单引号或者双引号，甚至可以直接使用JS取得DOM中我们需要的节点属性：</p>
<pre><code class="objective-c">//字符串转JS操作
- (void)webViewDidFinishLoad:(UIWebView *)webView

{
    NSString *sendJsStr=[NSString stringWithFormat:@&quot;openFile(\&quot;%@\&quot;)&quot;, jsDocPathStr];
    [webView stringByEvaluatingJavaScriptFromString:sendJsStr];

}

//将JS操作结果转换回字符串
- (void)webViewDidFinishLoad:(UIWebView *)webView

{
    CGRect frame = webView.frame;

    NSString *fitHeight = [webview stringByEvaluatingJavaScriptFromString:@&quot;document.body.scrollHeight;&quot;];

    frame.size.height = [fitHeight floatValue];

    webView.frame = frame;
}
</code></pre>
<p>剩下的一些与JS之间的交互可以参考这一篇博客<a href="http://blog.csdn.net/sheng_bin/article/details/53122706" target="_blank" rel="external">最全JS交互</a></p>


<!--<a href="http://yoursite.com/2017/12/08/iOS网络部分-一/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>