<html>
<head>
	
	<title>iOS逆向学习(四)</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">iOS逆向学习(四)</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2018年2月4日


    <a class="article-category-link" href="/categories/实战分享/">实战分享</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#美化截屏"><span class="toc-text">美化截屏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#对QQ的逆向分析"><span class="toc-text">对QQ的逆向分析</span></a></li></ol>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-04%20%E4%B8%8B%E5%8D%8810.40.46.png" height="350" width="600" alt=""></p>
<p>在初步上手了所有的工具之后，我们就需要来实战检测一下了，今天我以修改截屏功能和QQ的一些逆向经验来做一些小小的分享。</p>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在开始学习iOS逆向的人一般都会有正向开发的基础，那么我们会发现大部分Tweak当中都是用的MRC去编译OC文件，我们写的一些Tweak同样也要遵守这样的规则，但是这样会对一些已经熟悉ARC的程序猿带来很大的困扰，这里就简述一下如何使用ARC去编译OC文件：</p>
<p>我们只需要在Theos工程的MakeFile中添加一句话即可：</p>
<blockquote>
<p>ADDITIONAL_OBJFLAGS = -fobjc-arc</p>
</blockquote>
<p>后面的参数其实和我之前在讲MRC的时候在Xcode中添加的编译参数其实是一样的，那么类比过来就很简单了。</p>
<p>另外在熟悉了工具之后我也看过别人写的一些Tweak，主要是由C/C++、OC写的，其中所用的一些语法需要有一定的C++基础，比如说会经常出现<code>extern &quot;C&quot;...</code>这样的语句，所以推荐最好有扎实的C基础和C++入门并且具备一定的正向开发和汇编基础再去进行逆向的学习，不然一定会很痛苦的。</p>
<h1 id="美化截屏"><a href="#美化截屏" class="headerlink" title="美化截屏"></a>美化截屏</h1><p>当我们看到手机截屏的时候，是否可以想到可以自动的调整保存图片或着不保存，有没有想过切屏的时候可以做一些自己的小DIY来去美化这个过程，那么我们就来一起看看吧。</p>
<p>首先我们要知道截屏是SpringBoard在控制的，于是乎我们的第一步是从头文件开始分析，class-dump出头文件之后:</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-04%20%E4%B8%8B%E5%8D%8811.03.45.png" alt=""></p>
<p>可以看到有接近1300个头文件，如果我们每个每个看那还不得累死啊，于是乎我们想到因为是寻找截屏函数，在OC中的易读性是非常高的，所以我们选择使用<code>grep</code>去做一下模式匹配:</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-04%20%E4%B8%8B%E5%8D%8811.05.19.png" alt=""></p>
<p>果不其然，一下就被我们找到了这个类在哪里，那么掌控截屏应该就是这个SBScreenShotter类了，我们就来通过头文件看看有什么公有方法可以调用：</p>
<pre><code class="objective-c">
#import &quot;NSObject.h&quot;

@interface SBScreenShotter : NSObject
{
    _Bool _writingScreenshot;
    unsigned long long _screenshotWriteCount;
}

+ (id)sharedInstance;
- (void)_decrementWriteCount;
- (void)_incrementWriteCount;
- (_Bool)_isWritingSnapshot;
- (void)finishedWritingCarScreenshot:(id)arg1 didFinishSavingWithError:(id)arg2 context:(void *)arg3;
- (void)finishedWritingScreenshot:(id)arg1 didFinishSavingWithError:(id)arg2 context:(void *)arg3;
- (void)saveScreenshot:(_Bool)arg1;

@end
</code></pre>
<p>通过开发经验就可以看出来最后一个函数就是来保存截屏的了，直接通过<code>cycript</code>来测试一下：</p>
<pre><code class="shell">#cy choose(SBScreenShotter)
[0x1e457d81]
#cy [#0x1e457d81 saveScreenshot:YES]
#cy [#0x1e457d81 saveScreenshot:NO]
</code></pre>
<p>通过测试之后，原来那个BOOL类型的参数就是判断是否保存图片的了，我们会发现参数是YES还是NO的区别就是屏幕上是否会闪出白光，因为是屏幕产生的，所以我们可以大胆的猜测这个颜色也是可以更改的，那么我们继续去寻找一下：</p>
<pre><code class="shell">grep -r flash SpringBoard/
</code></pre>
<p>通过这个我们定位到一个<code>SBScreenFlash</code>类，里面的方法应该就是我们所需要寻找的了：</p>
<pre><code class="objective-c">#import &quot;NSObject.h&quot;

@class NSMutableArray, UIScreen, UIView, UIWindow;

@interface SBScreenFlash : NSObject
{
    NSMutableArray *_flashCompletionBlocks;
    UIScreen *_screen;
    UIWindow *_flashWindow;
    UIView *_flashView;
    _Bool _windowVisible;
}

+ (id)mainScreenFlasher;
- (void)_animationDidStop:(id)arg1 finished:(id)arg2 context:(void *)arg3;
- (void)_createUIWithColor:(id)arg1;
- (void)_orderWindowFront:(id)arg1 withColor:(id)arg2;
- (void)_orderWindowOut:(id)arg1;
- (void)_tearDown;
- (void)dealloc;
- (void)flashColor:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)flashWhiteWithCompletion:(CDUnknownBlockType)arg1;
- (id)initWithScreen:(id)arg1;

@end
</code></pre>
<p>从代码的第21行可以精准的定位到这个函数，但是这个参数<code>arg1</code>到底是什么类型，我们并不清楚，难道就此放弃？或者去猜测，这都不是合理的选择，我们可以通过编写Tweak去测试：</p>
<pre><code class="objective-c">%hook SBScreenFlash
 - (void)flashColor:(id)arg1 withCompletion:(id)arg2{
     %orig;
      NSLog(@&quot;flashColor: %s, %@&quot;, object_getClassName(arg1), arg1);
}
%end
</code></pre>
<p>然后安装之后再测试一遍，到系统日志里面去查看一下</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-04%20%E4%B8%8B%E5%8D%8811.20.17.png" alt=""></p>
<p>我们可以看到这个应该是UIColor的一个子类，根据继承的性质我们就可以知道该如何传递参数了，而且UIColor是一个公开类，所以解析到这里我们就可以编写Tweak了，当然首先用<code>cycript</code>测试一遍，直接用单例拿到对象：</p>
<pre><code class="shell">#cy [[SBScreenFlash mainScreenFlasher] flashColor:[UIColor redColor] withCompletion:nil]
</code></pre>
<p>果然屏幕闪过一道红光，那么这就算是成功了，但是单一的颜色不能满足需求，于是我决定使用随机的颜色：</p>
<pre><code class="objective-c">%hook SBScreenFlash

- (void)flashColor:(UIColor *)color withCompletion:(id)arg2{
  int R = (arc4random() % 256) ;
  int G = (arc4random() % 256) ;
  int B = (arc4random() % 256) ;
  %orig([UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:1], nil);
}

%end
</code></pre>
<p>注意如果我们用的是MRC去编译的话就必须采用上面这种写法，如果使用下面这种写法必须要在MakeFile中加入ARC的编译参数，不然每一次截屏都会调用的是同一个UIColor对象，那么颜色也会是一样的，就不是随机了：</p>
<pre><code class="objective-c">%hook SBScreenFlash

- (void)flashColor:(UIColor *)color withCompletion:(id)arg2{
  int R = (arc4random() % 256) ;
  int G = (arc4random() % 256) ;
  int B = (arc4random() % 256) ;
  UIColor *to = [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:1];
  %orig(to, nil);
}

%end
</code></pre>
<p>这是因为在MRC中用完一个对象之后要向他发送<code>release</code>消息，不然它将一直的滞留在内存之中，之后SpringBoard挂掉之后才会被回收。虽然不太清楚底层实现，所以我猜测MRC编译的时候每一次都会调用上一次的对象，第一次随机出来什么颜色就是什么颜色，之后respring之后才会改变，根据我的测试也确实如此，加了arc编译之后就可以正常的random啦。所以这是一个需要注意的小点，当然如果有谁知道了它的底层实现是如何导致这样的结果，可以在我的博客下方进行留言。</p>
<h1 id="对QQ的逆向分析"><a href="#对QQ的逆向分析" class="headerlink" title="对QQ的逆向分析"></a>对QQ的逆向分析</h1><p>只是玩一下截屏当然不能满足我们的好奇心，于是我又将手伸向了企鹅，但是企鹅是从StoreApp中下载的应用，所以首先应该砸壳，砸壳之后才能dump出他的头文件，但是dump之后发现出来了两个根本没用的头文件，所以class-dump也不是万能的，这个时候并不能止步，因为之前写过类似的IM类App，加上还有Reveal对其UI分析，所以我决定硬刚：</p>
<p>中间省略一长串在<code>cycript</code>中的测试过程，其实主要是测试控制器之间的关系，果然不出我所料，主界面是采用的抽屉控制器，然后是一个TabBarVc，里面有三个<code>UINavigationController</code>，然后每个Vc中又套着自定义的控制器，把这些都给撸顺了之后，就可以使用一下我们的黑魔法：</p>
<pre><code class="javascript">function printMethods(className) {
  var count = new new Type(&quot;I&quot;);
  var methods = class_copyMethodList(objc_getClass(className), count);
  var methodsArray = [];
  for(var i = 0; i &lt; *count; i++) {
    var method = methods[i];
    methodsArray.push({selector:method_getName(method), implementation:method_getImplementation(method)});
  }
  free(methods);
  free(count);
  return methodsArray;
}
</code></pre>
<p>通过这个类我们可以获取一个类的所有方法，但是这个并不是万能的，随意使用会导致程序crash掉，在这里我就不对整个QQ做介绍了，只分析一下<code>DrawerViewController</code></p>
<p>在命令行中执行：</p>
<pre><code class="shell">#cy printMethod(DrawerViewController)
</code></pre>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-04%20%E4%B8%8B%E5%8D%8811.52.24.png" alt=""></p>
<p>出来了一堆密密麻麻的函数，就拿<code>slideIn/OutByClick</code>举个例子吧，通过名字就知道这个应该是对侧边栏进行操作，滑进滑出，掌握了这些方法之后整个QQ也就为我们所掌控了，想要开发新的功能的话就需要更进一步的学习了，这里就不多提了，要善用利用工具和理性分析思考，这样就会发现逆向工程的世界特别的有趣。</p>
<p>作为友好提示的说一下就是如果在<code>cycript</code>中设置View的frame的时候是无法使用<code>initWithFrame</code>方法的，我们要么选择通过结构体，要么通过字典格式来表示我们的rect:</p>
<pre><code class="c">rect = new (struct CGRect)
rect-&gt;origin.x = 10
rect-&gt;origin.y = 10
rect-&gt;size.width = 10
rect-&gt;size.height = 10
[view setFrame:*rect];
</code></pre>
<p>或者我们直接选择用字典的格式来表示：</p>
<pre><code class="shell">rect = {0:{0:10,1:10},1:{0:10,1:10}}
</code></pre>
<p>这个一开始还折腾了半天，按照上面一种写法必须要加*，因为rect本身是一个结构体，所以要解引用将地址传过去。</p>


<!--<a href="http://yoursite.com/2018/02/04/iOS逆向学习-四/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>