<html>
<head>
	
	<title>ACM日常训练总结(二)</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">ACM日常训练总结(二)</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2018年3月16日


    <a class="article-category-link" href="/categories/算法/">算法</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HDU-1007"><span class="toc-text">HDU_1007</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HDU-1009"><span class="toc-text">HDU_1009</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flooded-Uva815"><span class="toc-text">Flooded_Uva815</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Uva-136"><span class="toc-text">Uva_136</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UVa-400"><span class="toc-text">UVa_400</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八届蓝桥-纸牌三角形"><span class="toc-text">第八届蓝桥_纸牌三角形</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#POJ-Anniversary-Cake"><span class="toc-text">POJ Anniversary Cake</span></a></li></ol>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-13%20%E4%B8%8B%E5%8D%8810.51.24.png" heigtht="350" width="600" alt=""></p>
<p>多写点DFS对于一个人的智力是有帮助的…</p>
<a id="more"></a>
<h1 id="HDU-1007"><a href="#HDU-1007" class="headerlink" title="HDU_1007"></a>HDU_1007</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1007" target="_blank" rel="external">传送门</a></p>
<p>为了找出最近的两个点之间的距离的一半，我们可以使用一个结构体去表示我们的坐标点，剩下的就是编写代码的问题了，这份代码还是比较简单的。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
using namespace std;
#define min(a,b) ( ((a)&gt;(b)) ? (b):(a) )
struct point
{
    double x,y;
}a[100001];
bool cmp(const point &amp;a,const point &amp;b)
{
    if(fabs(a.x-b.x)&lt;1e-8)
    //如果两个点的x坐标相等，则对y坐标进行比较
        return a.y &lt; b.y;
    return a.x&lt;b.x;
}
//两点间距离
double dis(point a,point b)
{
    return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));
}

double S(point a[],int n)
{
    double m=1e+10;
    if(n==2)
        return dis(a[0],a[1]);
    for(int i=0;i&lt;n-2;i++)
    { 
        m=min(m,min(dis(a[i],a[i+1]),min(dis(a[i],a[i+2]),dis(a[i+1],a[i+2]))));
    }
    return m;
}

int main()
{
    int n;
    while(scanf(&quot;%d&quot;,&amp;n),n)
    {
        for(int i=0;i&lt;n;i++)
        {
            scanf(&quot;%lf%lf&quot;,&amp;a[i].x,&amp;a[i].y);
        }
        sort(a,a+n,cmp);
        printf(&quot;%.2lf\n&quot;,S(a,n)/2);
    }
    return 0;
}
</code></pre>
<p>唯一一个有疑问的地方可能就是在输入的点大于2的情况下，为什么要比较三个点之间的距离关系取最小值，其实这个也只是为了过题目，因为只比较两个之间的最小值的话出现下面这种情况就不行了：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-16%20%E4%B8%8A%E5%8D%8811.25.06.png" alt="屏幕快照 2018-03-16 上午11.25.06.png"></p>
<p>所以为了过题多比较了一次，然后就过了，如果面对特别极端的情况的话还是需要想想其他的思路，如下图：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-16%20%E4%B8%8B%E5%8D%881.49.43.png" alt="屏幕快照 2018-03-16 下午1.49.43.png"></p>
<p>在这种情况下我的解决思路就是如果有x坐标相同的，那么就找到这个点之后第一个与其x坐标不相同的点，然后将二者之间的距离算出来，与当前最小值比较，体现在代码中应该就是：</p>
<pre><code class="cpp">if(a[i].x == a[i+1].x){
      int tmp2, tmp1;
      tmp1 = tmp2 = i;
    while(a[tmp1+1] == x)
      tmp1++;
  for(int j = tmp2 ; j &lt;= tmp1 ; j++){
    m = min(m, dis(a[j], a[tmp1]));
  }
      i = tmp2;
}
</code></pre>
<h1 id="HDU-1009"><a href="#HDU-1009" class="headerlink" title="HDU_1009"></a>HDU_1009</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1009" target="_blank" rel="external">传送门</a></p>
<p>主要是题目比较长，就是一道简单的贪心，我们将咖啡豆数量除猫粮的数量得到性价比，然后根据性价比对于数组进行排序，然后就是贪心的实现了，尽量的取，按照数组顺序，能拿完就尽量拿完。</p>
<pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

struct node{
  int a,b;
  double c;
}arr[1100];

int cmp(node x, node y){
  return x.c &gt; y.c;
}

int main(){
 int m,n;
 int i,j;
 double sum;
  while(~scanf(&quot;%d %d&quot;, &amp;m ,&amp;n)){
    for(i = 0 ; i &lt; n ; i++){
        scanf(&quot;%d %d&quot;, &amp;arr[i].a, &amp;arr[i].b);
          arr[i].c = (double)arr[i].a / arr[i],b;
    }
    sort(arr, arr+n, cmp);
    sum = 0;
    for(j = 0 ; j &lt; n ; j++){
      if(m &gt;= arr[i].b) sum += arr[i].a;
      else sum += m*(double)arr[i].a/arr[i].b;
      m -= arr[i].b;
      if(m &lt; 0) break;
    }
    printf(&quot;%.3lf\n&quot;, sum);
  }
  return 0;
}
</code></pre>
<h1 id="Flooded-Uva815"><a href="#Flooded-Uva815" class="headerlink" title="Flooded_Uva815"></a>Flooded_Uva815</h1><p>算法竞赛书上说可以锻炼思维的一道题，题目的意思就是说有一个n*m的网格，每个网格的面积都是10x10的正方形，现在洪水灌入，输入每个网格的海拔和洪水的体积，算百分之几的网格被淹没，以及水位的海拔高度：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
const int mmax=35*35;
int dp[mmax],n,m;

int main()
{
  //这种用法还是真少见
   for (int kase = 1; scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n &amp;&amp; m ; kase++)
   {
      n*=m;
      for(int i=0;i&lt;n;i++)
         cin&gt;&gt;dp[i];
      sort(dp,dp+n);
      dp[n]=0x7fffffff;

      int t;
      double sum;
      cin &gt;&gt; sum;
      sum/=100;

      for(t=1;t&lt;=n;t++)
      {
         sum += dp[t-1];
         if(sum/t&lt;=dp[t])
            break;
      }
      printf(&quot;Region %d\n&quot;, kase);
      printf(&quot;Water level is %.2lf meters.\n&quot;, sum/t);
      printf(&quot;%.2lf percent of the region is under water.\n\n&quot;, t*100.0/n);
   }
   return 0;
}
</code></pre>
<p>首先我们要对输入的网格海拔排序，因为海水肯定会先淹没高的，所以找到的第一个没有淹没的就OK了，为了防止全淹了，要将数组的最后一个设置为最大，跳出循环。这题的最大难度在于理解题目的意思，一开始我以为是往网格里面填，后来才知道是这个样子的：</p>
<p><img src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-23%20%E4%B8%8A%E5%8D%8811.59.59.png" alt="屏幕快照 2018-03-23 上午11.59.59.png"></p>
<h1 id="Uva-136"><a href="#Uva-136" class="headerlink" title="Uva_136"></a>Uva_136</h1><p>丑树是指不能被2，3，5以外的素数整除的数，将丑数从小到达排列起来，求第1500个丑数：</p>
<p>其实这个题的关键做法就在于想到丑数其实就是一开始的丑数的2、3、5倍，从一个丑数我们可以生成三个丑数，但是我们每次生成丑数的时候要判断这个丑数是否已经生成过了，我们可以用到STL来简单的完成我们的需求：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include&lt;set&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;

typedef long long LL;

const int coeff[3] = {2, 3, 5};

int main(){
  priority_queue&lt;LL , vector&lt;LL&gt;, greater&lt;LL&gt; &gt;pq;
  set&lt;LL&gt; s;
  pq.push(1);
  s.insert(1);
  for(int i = 1 ; ; i++){
    LL x = pq.top();
    pq.pop();
    if(i == 1500){
      cout &lt;&lt; x &lt;&lt; endl;
      break;
    }
    for(int j = 0 ; j &lt; 3 ; j++){
      LL x2 = x * coeff[j];
      if(!s.count(x2)){
        s.insert(x2);
        pq.push(x2);
      }
    }
  }
  return 0;
}
</code></pre>
<h1 id="UVa-400"><a href="#UVa-400" class="headerlink" title="UVa_400"></a>UVa_400</h1><p>这个其实就是实现Unix中的ls命令，每一行要求只有60个字符，那么在读入文件名的时候我们就把文件名最长给找到：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int maxcol = 60;
const int maxn = 100+5;
string filenames[maxn];

void print(const string &amp;s, int len, char extra){
  cout &lt;&lt; s;
  for(int i = 0 ; i &lt; len - s.length() ; i++){
    cout &lt;&lt; extra;
  }
}

int main(){
  int n;
  while(cin &gt;&gt; n){
    int M = 0;;
    for(int i = 0 ; i &lt; n ; i++){
      cin &gt;&gt; filenames[i];
      M = max(M, (int)filenames[i].length);
    }
    int cols = (maxcol - M)/(M+2) + 1;
    int rows = (n + M - 1)/cols;
    print(&quot;&quot;, 60, &#39;-&#39;);
    cout &lt;&lt; &#39;\n&#39;;
    sort(filenames, filenames+n);
    for(int r = 0 ; r &lt; rows ; r++)
      for(int c = 0 ; c &lt; cols ; c++){
        int index = c*rows + r;
        if(index &lt; n)print(filenames[index], c == cols-1 ? M : M+2, &#39; &#39;);
      }
    cout &lt;&lt; &quot;\n&quot;;
  }
  return 0;
}
</code></pre>
<h1 id="第八届蓝桥-纸牌三角形"><a href="#第八届蓝桥-纸牌三角形" class="headerlink" title="第八届蓝桥_纸牌三角形"></a>第八届蓝桥_纸牌三角形</h1><pre><code>标题：纸牌三角形
A,2,3,4,5,6,7,8,9 共9张纸牌排成一个正三角形（A按1计算）。要求每个边的和相等。
下图就是一种排法（如有对齐问题，参看p1.png）。

      A
     9 6
    4   8
   3 7 5 2

这样的排法可能会有很多。

如果考虑旋转、镜像后相同的算同一种，一共有多少种不同的排法呢？

请你计算并提交该数字。


注意：需要提交的是一个整数，不要提交任何多余内容。
</code></pre><p>因为翻转和镜像后算一种情况，所以这道题的关键在于查重，那么STL中的set就能帮上我们的忙了，分析完重复的情况之后我们发现每种情况有六个重复的：</p>
<pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include&lt;algorithm&gt;
using namespace std;

set&lt;vector&lt;int&gt; &gt;st;

int main(){
  int arr[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
  do{
    if(arr[0] + arr[1] + arr[2] + arr[3] == arr[3] + arr[4] + arr[5] +arr[6] &amp;&amp; arr[3] + arr[4] + arr[5] +arr[6] == arr[6] + arr[7] + arr[8] + arr[0]){
      vector&lt;int&gt; a;
      vector&lt;int&gt; b;
      vector&lt;int&gt; c;
      vector&lt;int&gt; d;
      vector&lt;int&gt; e;
      vector&lt;int&gt; f;
      for(int i=0;i&lt;=8;i++){
                  a.push_back(arr[i%9]);                  
              }

      for(int i=0;i&lt;=8;i++){
                  b.push_back(arr[(i+3)%9]);
              }

      for(int i=0;i&lt;=8;i++){
                  c.push_back(arr[(i+6)%9]);
              }

      for(int i=9;i&gt;=1;i--){
                  d.push_back(arr[i%9]);
              }

      for(int i=9;i&gt;=1;i--){
                  e.push_back(arr[(i+3)%9]);
              }

      for(int i=9;i&gt;=1;i--){
                  f.push_back(arr[(i+6)%9]);
              }

      if(!st.count(a)&amp;&amp;!st.count(b) &amp;&amp;!st.count(c) &amp;&amp;!st.count(d) 
         &amp;&amp;!st.count(e) &amp;&amp;!st.count(f)){
        st.insert(a);
      }
    }
  }while(next_permutation(arr, arr+9));
  cout &lt;&lt; st.size() &lt;&lt; endl;
  return 0;
}
</code></pre>
<h1 id="POJ-Anniversary-Cake"><a href="#POJ-Anniversary-Cake" class="headerlink" title="POJ Anniversary Cake"></a>POJ Anniversary Cake</h1><p><a href="https://blog.csdn.net/lyy289065406/article/details/6683250" target="_blank" rel="external">思路讲解</a></p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;

int col[41];
int s, n;
int sizenum[11];

int dfs(int dep){
  if(dep == n) return 1;
  int prow,minn = 50;
  for(int i = 1 ; i &lt;= s ;i++){
    if(minn &gt; col[i]){
      minn = col[i];
      prow = i;
    }
  }
  int size,p;
  for(size = 10 ; size &gt; 0 ; size--){
    if(!sizenum[size]) continue;
    if(s - col[prow] &gt;= size &amp;&amp; s - prow + 1 &gt;= size){
      for(p = prow ; p &lt;= prow + size -1 ; p++)
        if(col[p] != col[prow]) break;
      if(p == prow + size){
        for(p = prow; p &lt;= prow + size - 1; p++) col[p] += size;
        sizenum[size]--;
        if(dfs(dep + 1)) return 1;  //若为假则下面回溯
        sizenum[size]++;
        for(p = prow; p &lt;= prow + size - 1; p++) col[p] -= size;  
      }
    } 
  }
  return 0;
}

int main(){
  int t;
  cin &gt;&gt; t;
  while(t--){
    scanf(&quot;%d %d&quot;, &amp;s, &amp;n);
    memset(col, 0, sizeof(col));
    memset(sizenum, 0, sizeof(sizenum));
    int area = 0,sid;
    for(int i = 1 ; i &lt;= n ; i++){
      cin &gt;&gt; sid;
      sizenum[sid]++;
      area += sid*sid;
    }
    if(area != s*s){
      cout &lt;&lt; &quot;HUTUTU!\n&quot;;
      continue;
    }
    if(dfs(0)) cout &lt;&lt; &quot;KHOOOOB!\n&quot;;
    else cout &lt;&lt; &quot;HUTUTU!\n&quot;; 
  }
  return 0;
}
</code></pre>


<!--<a href="http://yoursite.com/2018/03/16/ACM日常训练总结-二/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>