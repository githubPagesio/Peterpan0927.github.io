<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>黑书动态规划习题 | Peterpan&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="书中小部分给了伪代码，大部分都是状态转移方程，考虑实现的问题，所以对其中的部分习题做一个汇总，主要针对动归的一些核心思想进行解释，如最优子结构还有决策的无后效性。(高中生实在太强了，菜狗要退坑了！！！)
有时候一道题搞了半天还是有点晕乎乎的…">
<meta property="og:type" content="article">
<meta property="og:title" content="黑书动态规划习题">
<meta property="og:url" content="http://yoursite.com/2018/04/16/黑书动态规划习题/index.html">
<meta property="og:site_name" content="Peterpan's Blog">
<meta property="og:description" content="书中小部分给了伪代码，大部分都是状态转移方程，考虑实现的问题，所以对其中的部分习题做一个汇总，主要针对动归的一些核心思想进行解释，如最优子结构还有决策的无后效性。(高中生实在太强了，菜狗要退坑了！！！)
有时候一道题搞了半天还是有点晕乎乎的…">
<meta property="og:updated_time" content="2018-04-18T09:00:35.220Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="黑书动态规划习题">
<meta name="twitter:description" content="书中小部分给了伪代码，大部分都是状态转移方程，考虑实现的问题，所以对其中的部分习题做一个汇总，主要针对动归的一些核心思想进行解释，如最优子结构还有决策的无后效性。(高中生实在太强了，菜狗要退坑了！！！)
有时候一道题搞了半天还是有点晕乎乎的…">
  
    <link rel="alternate" href="/atom.xml" title="Peterpan&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/p1.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/plugin/bganimation/bg.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%8811.42.23.png">
    <h2 class="author">Peter pan</h2>
    <h3 class="description">the mark of an educated mind is to be able to entertain a thought without accepting it</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>97</strong><br>文章</div></a>
      <a href="/categories"><div><strong>89</strong><br>分类</div></a>
      <a href="/tags"><div><strong>14</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-黑书动态规划习题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/16/黑书动态规划习题/" class="article-date">
  <time class="post-time" datetime="2018-04-16T02:39:59.000Z" itemprop="datePublished">
    <span class="post-month">4月</span><br/>
    <span class="post-day">16</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      黑书动态规划习题
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/动态规划/">动态规划</a>
  </div>

          
              
  &nbsp; | &nbsp;
  <div class="view-box">
    <span id="/2018/04/16/黑书动态规划习题/" class="leancloud_visitors" data-flag-title="黑书动态规划习题">
      &nbsp;阅读次数<span class="leancloud-visitors-count"></span>
    </span>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>书中小部分给了伪代码，大部分都是状态转移方程，考虑实现的问题，所以对其中的部分习题做一个汇总，主要针对动归的一些核心思想进行解释，如最优子结构还有决策的无后效性。(高中生实在太强了，菜狗要退坑了！！！)</p>
<p>有时候一道题搞了半天还是有点晕乎乎的…</p>
<a id="more"></a>
<h1 id="括号序列"><a class="markdownIt-Anchor" href="#括号序列"></a> 括号序列</h1>
<p>我们的目的是为了添加尽量少的括号得到一个规则的序列，所以我们从子序列的两边开始向中间收缩，为了优化，我们可以在递归的过程中加上记忆化，或者按照一定的顺序计算，也就是直接开for，下面的我们可以很清楚的看到是<code>O(n3)</code>的复杂度，我们开一个dp的二维数字来表示左右边界，其中的值代表需要添加的最小括号数：</p>
<pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;  </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;  </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;  </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;  </span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;  </span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 99999999  </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 111  </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{  
    <span class="hljs-built_in">string</span> a;  
    <span class="hljs-built_in">cin</span>&gt;&gt;a;  
    <span class="hljs-keyword">int</span> l=a.length();  
    <span class="hljs-keyword">int</span> dp[maxn][maxn];  
  	<span class="hljs-comment">//预处理，在区间为2只有单边括号的情况下将值置为1</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;l;i++) dp[i][i]=<span class="hljs-number">1</span>;  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> len=<span class="hljs-number">2</span>;len&lt;=l;len++){  
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> s=<span class="hljs-number">0</span>;s&lt;=l-len;s++){  
            <span class="hljs-keyword">int</span> e=s+len<span class="hljs-number">-1</span>;  
            dp[s][e]=inf;  
            <span class="hljs-keyword">if</span>((a[s]==<span class="hljs-string">'('</span>&amp;&amp;a[e]==<span class="hljs-string">')'</span>)||(a[s]==<span class="hljs-string">'['</span>&amp;&amp;a[e]==<span class="hljs-string">']'</span>))   
                dp[s][e]=min(dp[s][e],dp[s+<span class="hljs-number">1</span>][e<span class="hljs-number">-1</span>]);  
            <span class="hljs-keyword">if</span>((a[s]==<span class="hljs-string">'('</span>&amp;&amp;a[e]!=<span class="hljs-string">')'</span>)||(a[s]==<span class="hljs-string">'['</span>&amp;&amp;a[e]!=<span class="hljs-string">']'</span>))   
                dp[s][e]=min(dp[s][e],dp[s][e<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>);  
            <span class="hljs-keyword">if</span>((a[e]==<span class="hljs-string">')'</span>&amp;&amp;a[s]!=<span class="hljs-string">'('</span>)||(a[e]==<span class="hljs-string">']'</span>&amp;&amp;a[s]!=<span class="hljs-string">'['</span>))   
                dp[s][e]=min(dp[s][e],dp[s+<span class="hljs-number">1</span>][e]+<span class="hljs-number">1</span>);  
          	<span class="hljs-comment">//状态转移</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=s;k&lt;e;k++){  
                dp[s][e]=min(dp[s][e],dp[s][k]+dp[k+<span class="hljs-number">1</span>][e]);  
            }  
        }  
    }  
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dp[<span class="hljs-number">0</span>][l<span class="hljs-number">-1</span>]);  
}  
</code></pre>
<p>这里要说一下关于最优化原理和最优子结构的问题，当把原问题转换为规模更小的子问题的时候，原问题最优当且仅当子问题最优，这就是最优化原理，但是这并不是很好看出来，就像我们做贪心的时候最重要的就是能证他是贪心。上面的问题中就是这个样子，满足最优化原理的就拥有着最优化子结构。上面的三重循环中，第一层是按一定顺序计算状态，第二层是在计算每个状态的不同递推路径，也可以称作决策，最后一层进行每一个状态的状态转移。</p>
<p>其实在动态规划的题目中，最关键的地方就是它的状态和状态转移方程，如果能得到基本上这道题就完成的差不多了。</p>
<p>#舞蹈家怀特先生</p>
<p>从这个题目中我们来说明一下上面叫做无后效性，意思就是说怀特先生每次在进行舞步的切换也就是在做决策的时候只取决于他当前的位置，也就是说和之前的状态没有任何的关系，因为之前的状态已经是由前一个最优的状态得到的了，无后效性是应用动态规划的重要条件，不然我们状态迁移就是不合理的，因为一个状态</p>
<pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 10010</span>
<span class="hljs-keyword">int</span> a[N];
<span class="hljs-keyword">int</span> f[N][<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];
<span class="hljs-keyword">int</span> n,ans = <span class="hljs-number">100000</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">odd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{    <span class="hljs-keyword">if</span> (x%<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span>
</span>{
    <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (!(x &amp;&amp; y)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span> (odd(x) == odd(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a[i]);
    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">127</span>/<span class="hljs-number">4</span>,<span class="hljs-keyword">sizeof</span>(f));
    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
  	<span class="hljs-comment">//枚举舞步</span>
     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">4</span>;j++)<span class="hljs-comment">//注意从0开始枚举，因为一开始在0格子上 </span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;=<span class="hljs-number">4</span>;k++)
            {
                f[i][j][a[i]] = min(f[i][j][a[i]],f[i<span class="hljs-number">-1</span>][j][k]+move(a[i],k));
                f[i][a[i]][k] = min(f[i][a[i]][k],f[i<span class="hljs-number">-1</span>][j][k]+move(a[i],j));
            }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">4</span>;i++)<span class="hljs-comment">//注意从0开始枚举 </span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;=<span class="hljs-number">4</span>;j++)
        ans = min(ans,f[n][i][j]);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,ans);
}
</code></pre>
<h1 id="积木游戏"><a class="markdownIt-Anchor" href="#积木游戏"></a> 积木游戏</h1>
<p>这个题目有两种递推的方式，一个是给定状态之后推导前躯，然后取得最优，一个是推导后继，得到最优，我选择第一种方式，利用递归来算出前驱节点，这样避免无用状态，也方便自顶向下剪枝，那么首先我们要知道这个题目的影响条件和可以做出的决策种类，对于每一个积木，我们都有三种决策：</p>
<ol>
<li>不使用这个积木</li>
<li>放到前一个堆上</li>
<li>另外开一个新的堆</li>
</ol>
<p>所以我们用一个4维数组来表示我们状态的转移，这个我们还是用递归加记忆化做，用递推太麻烦….</p>
<pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Memset(a,b) memset(a,b,sizeof(a))</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 0x3f3f3f3f</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Retangle</span>{</span>
  <span class="hljs-keyword">int</span> a,b,c;
};

<span class="hljs-keyword">int</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">110</span>][<span class="hljs-number">110</span>][<span class="hljs-number">3</span>];
<span class="hljs-keyword">int</span> N,M;
Retangle r[<span class="hljs-number">100</span>];

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">geta</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> statu)</span></span>{
  <span class="hljs-keyword">int</span> a = r[pos].a;
  <span class="hljs-keyword">int</span> b = r[pos].b;
  <span class="hljs-keyword">int</span> c = r[pos].c;

  <span class="hljs-keyword">if</span>(statu == <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> a &gt; b ? a : b;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(statu == <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> a &gt; c ? a : c;
  <span class="hljs-keyword">else</span> 
    <span class="hljs-keyword">return</span> b &gt; c ? b : c;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getb</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> statu)</span></span>{
  <span class="hljs-keyword">int</span> a = r[pos].a;
  <span class="hljs-keyword">int</span> b = r[pos].b;
  <span class="hljs-keyword">int</span> c = r[pos].c;

  <span class="hljs-keyword">if</span>(statu == <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> a &gt; b ? b : a;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(statu == <span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> a &gt; c ? c :a;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b &gt; c ? c : b;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> pos, <span class="hljs-keyword">int</span> pre, <span class="hljs-keyword">int</span> statu)</span></span>{
  <span class="hljs-keyword">if</span>(pos &gt; N) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-comment">//记忆化</span>
  <span class="hljs-keyword">if</span>(dp[num][pos][pre][statu]!=<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> dp[num][pos][pre][statu];
  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;
  <span class="hljs-comment">//丢弃</span>
  ans = max(ans, DFS(num,pos+<span class="hljs-number">1</span>,pre,statu));
  <span class="hljs-comment">//新开一堆</span>
  <span class="hljs-keyword">if</span>(num &lt; M){
    ans = max(ans, r[pos].c + DFS(num+<span class="hljs-number">1</span>, pos+<span class="hljs-number">1</span>, pos, <span class="hljs-number">0</span>));
    ans = max(ans, r[pos].b + DFS(num+<span class="hljs-number">1</span>, pos+<span class="hljs-number">1</span>, pos, <span class="hljs-number">1</span>));
    ans = max(ans, r[pos].a + DFS(num+<span class="hljs-number">1</span>, pos+<span class="hljs-number">1</span>, pos, <span class="hljs-number">2</span>));
  }
  <span class="hljs-comment">//加在之前的堆上</span>
  <span class="hljs-keyword">int</span> prea=geta(pre, statu),preb=getb(pre, statu);
  <span class="hljs-keyword">int</span> posa,posb;
  posa = geta(pos,<span class="hljs-number">0</span>), posb = getb(pos,<span class="hljs-number">0</span>);
  <span class="hljs-keyword">if</span>(posa &lt;= prea &amp;&amp; posb &lt;= preb)
    ans = max(ans, DFS(num, pos+<span class="hljs-number">1</span>, pos,<span class="hljs-number">0</span>));
  posa = geta(pos,<span class="hljs-number">1</span>), posb = getb(pos, <span class="hljs-number">1</span>);
  <span class="hljs-keyword">if</span>(posa &lt;= prea &amp;&amp; posb &lt;= preb)
    ans = max(ans, DFS(num,pos+<span class="hljs-number">1</span>,pos,<span class="hljs-number">1</span>));
  posa = geta(pos,<span class="hljs-number">2</span>), posb = getb(pos, <span class="hljs-number">2</span>);
  <span class="hljs-keyword">if</span>(posa &lt;= prea &amp;&amp; posb &lt;= preb)
    ans = max(ans, DFS(num,pos+<span class="hljs-number">1</span>,pos,<span class="hljs-number">2</span>));
  <span class="hljs-keyword">return</span> dp[num][pos][pre][statu] = ans;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; N &gt;&gt; M){
    r[<span class="hljs-number">0</span>].a = r[<span class="hljs-number">0</span>].b = r[<span class="hljs-number">0</span>].c = MAX;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N ;i++){
      <span class="hljs-built_in">cin</span> &gt;&gt;  r[i].a &gt;&gt;  r[i].b &gt;&gt; r[i].c;
    }
    Memset(dp,<span class="hljs-number">-1</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; DFS(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h1 id="方块消除"><a class="markdownIt-Anchor" href="#方块消除"></a> 方块消除</h1>
<p>这个题目我们可以将状态稍微压缩一下，也就是相同的一串数字，我们可以用一个二元组来表示，一个代表种类，一个代表个数，然后我们枚举起点，还有结束的位置，以及之后还有多少个相同的序列可以一起消除(说不清楚…)，把状态转移方程写出来估计就懂了：</p>
<p>我们需要构造一个三维数组来表示状态，第一位表示我们的起始点，第二位是我们的结束点，第三位是结束点之后还有多少个和前面一起消除的序列组。</p>
<blockquote>
<p>f[i,j,k] = max(f(i,j-1,0)+(len[j]+k)*(len(j)+k),  f[i,p,k+len[j]]+f(p+1,j-1,0))</p>
</blockquote>
<pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;  </span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  
  
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(a, b) a&gt;b?a:b  </span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 202  </span>
  
<span class="hljs-keyword">int</span> color[N], len[N], after[N];  
<span class="hljs-keyword">int</span> dp[N][N][N];  
  
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  
</span>{  
    <span class="hljs-keyword">int</span> cas, m, n;  
    <span class="hljs-keyword">int</span> i, j, l, r, k, p, id;  
    <span class="hljs-keyword">int</span> seq[N], cnt;  
    <span class="hljs-keyword">bool</span> vis[N];  
      
    cas = <span class="hljs-number">1</span>;  
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;m);  
    <span class="hljs-keyword">while</span>(m--)  
    {  
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);  
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;seq[<span class="hljs-number">1</span>]);  
        id = cnt = <span class="hljs-number">1</span>;  
        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n; i++){  
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;seq[i]);  
            <span class="hljs-keyword">if</span>(seq[i] == seq[i<span class="hljs-number">-1</span>])  
                cnt++;  
            <span class="hljs-keyword">else</span> {  
                color[id] = seq[i<span class="hljs-number">-1</span>];  
                len[id++] = cnt;  
                cnt = <span class="hljs-number">1</span>;  
            }  
        }  
        color[id] = seq[n];  
        len[id++] = cnt;  
          
        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span>(vis));  
        <span class="hljs-keyword">for</span>(i = id<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">1</span>; i--){ <span class="hljs-comment">/*此处after[i]记录i之后与i颜色相同的方块最多有多少个*/</span>                                       <span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;  after[i] = <span class="hljs-number">0</span>;  
            <span class="hljs-keyword">int</span> tmp = i;  
            <span class="hljs-keyword">for</span>(j = i<span class="hljs-number">-2</span>; j &gt;= <span class="hljs-number">1</span>; j--)  
                <span class="hljs-keyword">if</span>(color[j] == color[tmp]){  
                    after[j] = after[tmp] + len[tmp];  
                    tmp = j;  
                    vis[j--] = <span class="hljs-literal">true</span>;  
                }  
        }  
      
        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dp));  
        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; id; j++){  <span class="hljs-comment">//按长度遍历  </span>
            <span class="hljs-keyword">for</span>(l = <span class="hljs-number">1</span>; l+j<span class="hljs-number">-1</span> &lt; id; l++){    
                r = l+j<span class="hljs-number">-1</span>;  
                <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt;= after[r]; k++){ <span class="hljs-comment">//k为未来接在r后的方块数  </span>
                    dp[l][r][k] = dp[l][r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+(len[r]+k)*(len[r]+k);  
                    <span class="hljs-keyword">for</span>(p = r<span class="hljs-number">-2</span>; p &gt;= l; p--)  
                        <span class="hljs-keyword">if</span>(color[p] == color[r])  
                            dp[l][r][k] = MAX(dp[l][r][k], dp[l][p][k+len[r]]+dp[p+<span class="hljs-number">1</span>][r<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);  
                }  
            }  
        }  
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Case %d: %d\n"</span>, cas++, dp[<span class="hljs-number">1</span>][id<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]);  
    }  
    system(<span class="hljs-string">"pause"</span>);  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/16/黑书动态规划习题/" data-id="cjg9k0mfr008e9fbrkpvxip9t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACM/">ACM</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/04/17/反动态调试保护的实现和破解/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          反动态调试保护的实现和破解
        
      </div>
    </a>
  
  
    <a href="/2018/04/15/重探OC之Type-Value篇/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">重探OC之Type&amp;Value篇</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Peterpan&#39;s Blog</h1>
    <h2 class="blog-subtitle">Mind over muscle.</h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="http://omunhj2f1.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%8811.42.23.png">
    <h2 class="author">Peter pan</h2>
    <h3 class="description">the mark of an educated mind is to be able to entertain a thought without accepting it</h3>
    <div class="count-box">
      <a href="/archives"><div><strong>97</strong><br>文章</div></a>
      <a href="/categories"><div><strong>89</strong><br>分类</div></a>
      <a href="/tags"><div><strong>14</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="http://github.com/Peterpan0927" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>友情链接</h2>
      
        <a class="hvr-bounce-in" href="https://www.imbajin.com" target="_blank" title="Jin">
          Jin
        </a>
      
        <a class="hvr-bounce-in" href="https://yinwang0.wordpress.com" target="_blank" title="Yinwang(English)">
          Yinwang(English)
        </a>
      
        <a class="hvr-bounce-in" href="http://www.yinwang.org" target="_blank" title="Yinwang(Chinese)">
          Yinwang(Chinese)
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2017 - 2018 Peter pan<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  <link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
  <script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>



  <link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">
  <script src="/plugin/galmenu/GalMenu.js"></script>
  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/about" title="" class="menuItem">音乐</a>
          
            <a href="/archives" title="" class="menuItem">归档</a>
          
            <a href="https://github.com/Peterpan0927" title="" class="menuItem">Github</a>
          
            <a href="ftp://118.89.38.168" title="" class="menuItem">FTP</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>
<script src="/js/script.js"></script>




  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("Ljd6bJFL9N4tWj6WnGcbYUd2-gzGzoHsz", "xDGMWtxNt0aReJDVkuYmSqBd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.article-title').length > 1) {
        showTime(Counter);
      }
    });
  </script>





  </div>
</body>
</html>