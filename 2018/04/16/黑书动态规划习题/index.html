<html>
<head>
	
	<title>黑书动态规划习题</title>
	<meta name="keywords" content="fzb.me,冯宗宝,冯宗宝的blog" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    
	   <link href="/css/main.css?v=3" rel="stylesheet" type="text/css" />
    
        <script src="/js/util.js"></script>
        <script>
            if(isMobile()) {
                loadjscssfile('../css/mobile.css', 'css');
            } else {
                loadjscssfile('../css/desktop.css', 'css');
            }
        </script> 
    

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">

    
	<link rel="shortcut icon" type="image/x-icon" href="/p1.png?v=3"/>
    

</head>

<body>


<h2 class="title">黑书动态规划习题</h2>
<!---
<div style="text-align:center;margin-top: -10px;">
<div class="article-category">
发表于2018年4月16日


    <a class="article-category-link" href="/categories/动态规划/">动态规划</a>



 </div>
--->
</div>

<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#括号序列"><span class="toc-text">括号序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#积木游戏"><span class="toc-text">积木游戏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#方块消除"><span class="toc-text">方块消除</span></a></li></ol>
<p>书中小部分给了伪代码，大部分都是状态转移方程，考虑实现的问题，所以对其中的部分习题做一个汇总，主要针对动归的一些核心思想进行解释，如最优子结构还有决策的无后效性。(高中生实在太强了，菜狗要退坑了！！！)</p>
<p>有时候一道题搞了半天还是有点晕乎乎的…</p>
<a id="more"></a>
<h1 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h1><p>我们的目的是为了添加尽量少的括号得到一个规则的序列，所以我们从子序列的两边开始向中间收缩，为了优化，我们可以在递归的过程中加上记忆化，或者按照一定的顺序计算，也就是直接开for，下面的我们可以很清楚的看到是<code>O(n3)</code>的复杂度，我们开一个dp的二维数字来表示左右边界，其中的值代表需要添加的最小括号数：</p>
<pre><code class="cpp">#include&lt;stdio.h&gt;  
#include&lt;string.h&gt;  
#include&lt;iostream&gt;  
#include&lt;algorithm&gt;  
#include&lt;cstring&gt;  
using namespace std;  
#define inf 99999999  
#define maxn 111  
int main(){  
    string a;  
    cin&gt;&gt;a;  
    int l=a.length();  
    int dp[maxn][maxn];  
      //预处理，在区间为2只有单边括号的情况下将值置为1
    for(int i=0;i&lt;l;i++) dp[i][i]=1;  
    for(int len=2;len&lt;=l;len++){  
        for(int s=0;s&lt;=l-len;s++){  
            int e=s+len-1;  
            dp[s][e]=inf;  
            if((a[s]==&#39;(&#39;&amp;&amp;a[e]==&#39;)&#39;)||(a[s]==&#39;[&#39;&amp;&amp;a[e]==&#39;]&#39;))   
                dp[s][e]=min(dp[s][e],dp[s+1][e-1]);  
            if((a[s]==&#39;(&#39;&amp;&amp;a[e]!=&#39;)&#39;)||(a[s]==&#39;[&#39;&amp;&amp;a[e]!=&#39;]&#39;))   
                dp[s][e]=min(dp[s][e],dp[s][e-1]+1);  
            if((a[e]==&#39;)&#39;&amp;&amp;a[s]!=&#39;(&#39;)||(a[e]==&#39;]&#39;&amp;&amp;a[s]!=&#39;[&#39;))   
                dp[s][e]=min(dp[s][e],dp[s+1][e]+1);  
              //状态转移
            for(int k=s;k&lt;e;k++){  
                dp[s][e]=min(dp[s][e],dp[s][k]+dp[k+1][e]);  
            }  
        }  
    }  
    printf(&quot;%d\n&quot;,dp[0][l-1]);  
}
</code></pre>
<p>这里要说一下关于最优化原理和最优子结构的问题，当把原问题转换为规模更小的子问题的时候，原问题最优当且仅当子问题最优，这就是最优化原理，但是这并不是很好看出来，就像我们做贪心的时候最重要的就是能证他是贪心。上面的问题中就是这个样子，满足最优化原理的就拥有着最优化子结构。上面的三重循环中，第一层是按一定顺序计算状态，第二层是在计算每个状态的不同递推路径，也可以称作决策，最后一层进行每一个状态的状态转移。</p>
<p>其实在动态规划的题目中，最关键的地方就是它的状态和状态转移方程，如果能得到基本上这道题就完成的差不多了。</p>
<p>#舞蹈家怀特先生</p>
<p>从这个题目中我们来说明一下上面叫做无后效性，意思就是说怀特先生每次在进行舞步的切换也就是在做决策的时候只取决于他当前的位置，也就是说和之前的状态没有任何的关系，因为之前的状态已经是由前一个最优的状态得到的了，无后效性是应用动态规划的重要条件，不然我们状态迁移就是不合理的，因为一个状态</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
#define N 10010
int a[N];
int f[N][5][5];
int n,ans = 100000;
int odd(int x) {    if (x%2) return 1;else return 0;}
int move(int x,int y)
{
    if (x == y) return 1;
    if (!(x &amp;&amp; y)) return 2;
    if (odd(x) == odd(y)) return 4;
    return 3;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    memset(f,127/4,sizeof(f));
    f[0][0][0] = 0;
      //枚举舞步
     for (int i=1;i&lt;=n;i++)
        for (int j=0;j&lt;=4;j++)//注意从0开始枚举，因为一开始在0格子上 
            for (int k=0;k&lt;=4;k++)
            {
                f[i][j][a[i]] = min(f[i][j][a[i]],f[i-1][j][k]+move(a[i],k));
                f[i][a[i]][k] = min(f[i][a[i]][k],f[i-1][j][k]+move(a[i],j));
            }
    for (int i=0;i&lt;=4;i++)//注意从0开始枚举 
        for (int j=0;j&lt;=4;j++)
        ans = min(ans,f[n][i][j]);
    printf(&quot;%d&quot;,ans);
}
</code></pre>
<h1 id="积木游戏"><a href="#积木游戏" class="headerlink" title="积木游戏"></a>积木游戏</h1><p>这个题目有两种递推的方式，一个是给定状态之后推导前躯，然后取得最优，一个是推导后继，得到最优，我选择第一种方式，利用递归来算出前驱节点，这样避免无用状态，也方便自顶向下剪枝，那么首先我们要知道这个题目的影响条件和可以做出的决策种类，对于每一个积木，我们都有三种决策：</p>
<ol>
<li>不使用这个积木</li>
<li>放到前一个堆上</li>
<li>另外开一个新的堆</li>
</ol>
<p>所以我们用一个4维数组来表示我们状态的转移，这个我们还是用递归加记忆化做，用递推太麻烦….</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define Memset(a,b) memset(a,b,sizeof(a))
typedef long long LL;
#define MAX 0x3f3f3f3f
using namespace std;

struct Retangle{
  int a,b,c;
};

int dp[110][110][110][3];
int N,M;
Retangle r[100];

int geta(int pos, int statu){
  int a = r[pos].a;
  int b = r[pos].b;
  int c = r[pos].c;

  if(statu == 0)
    return a &gt; b ? a : b;
  else if(statu == 1)
    return a &gt; c ? a : c;
  else 
    return b &gt; c ? b : c;
}

int getb(int pos, int statu){
  int a = r[pos].a;
  int b = r[pos].b;
  int c = r[pos].c;

  if(statu == 0)
    return a &gt; b ? b : a;
  else if(statu == 1)
    return a &gt; c ? c :a;
  else return b &gt; c ? c : b;
}

int DFS(int num, int pos, int pre, int statu){
  if(pos &gt; N) return 0;
  //记忆化
  if(dp[num][pos][pre][statu]!=-1)
    return dp[num][pos][pre][statu];
  int ans = 0;
  //丢弃
  ans = max(ans, DFS(num,pos+1,pre,statu));
  //新开一堆
  if(num &lt; M){
    ans = max(ans, r[pos].c + DFS(num+1, pos+1, pos, 0));
    ans = max(ans, r[pos].b + DFS(num+1, pos+1, pos, 1));
    ans = max(ans, r[pos].a + DFS(num+1, pos+1, pos, 2));
  }
  //加在之前的堆上
  int prea=geta(pre, statu),preb=getb(pre, statu);
  int posa,posb;
  posa = geta(pos,0), posb = getb(pos,0);
  if(posa &lt;= prea &amp;&amp; posb &lt;= preb)
    ans = max(ans, DFS(num, pos+1, pos,0));
  posa = geta(pos,1), posb = getb(pos, 1);
  if(posa &lt;= prea &amp;&amp; posb &lt;= preb)
    ans = max(ans, DFS(num,pos+1,pos,1));
  posa = geta(pos,2), posb = getb(pos, 2);
  if(posa &lt;= prea &amp;&amp; posb &lt;= preb)
    ans = max(ans, DFS(num,pos+1,pos,2));
  return dp[num][pos][pre][statu] = ans;
}

int main(){
  while(cin &gt;&gt; N &gt;&gt; M){
    r[0].a = r[0].b = r[0].c = MAX;
    for(int i = 1; i &lt;= N ;i++){
      cin &gt;&gt;  r[i].a &gt;&gt;  r[i].b &gt;&gt; r[i].c;
    }
    Memset(dp,-1);
    cout &lt;&lt; DFS(1,1,0,0) &lt;&lt; endl;
  }
  return 0;
}
</code></pre>
<h1 id="方块消除"><a href="#方块消除" class="headerlink" title="方块消除"></a>方块消除</h1><p>这个题目我们可以将状态稍微压缩一下，也就是相同的一串数字，我们可以用一个二元组来表示，一个代表种类，一个代表个数，然后我们枚举起点，还有结束的位置，以及之后还有多少个相同的序列可以一起消除(说不清楚…)，把状态转移方程写出来估计就懂了：</p>
<p>我们需要构造一个三维数组来表示状态，第一位表示我们的起始点，第二位是我们的结束点，第三位是结束点之后还有多少个和前面一起消除的序列组。</p>
<blockquote>
<p>f[i,j,k] = max(f(i,j-1,0)+(len[j]+k)*(len(j)+k),  f[i,p,k+len[j]]+f(p+1,j-1,0))</p>
</blockquote>
<pre><code class="cpp">#include &lt;iostream&gt;  
using namespace std;  

#define MAX(a, b) a&gt;b?a:b  
#define N 202  

int color[N], len[N], after[N];  
int dp[N][N][N];  

int main()  
{  
    int cas, m, n;  
    int i, j, l, r, k, p, id;  
    int seq[N], cnt;  
    bool vis[N];  

    cas = 1;  
    scanf(&quot;%d&quot;, &amp;m);  
    while(m--)  
    {  
        scanf(&quot;%d&quot;, &amp;n);  
        scanf(&quot;%d&quot;, &amp;seq[1]);  
        id = cnt = 1;  
        for(i = 2; i &lt;= n; i++){  
            scanf(&quot;%d&quot;, &amp;seq[i]);  
            if(seq[i] == seq[i-1])  
                cnt++;  
            else {  
                color[id] = seq[i-1];  
                len[id++] = cnt;  
                cnt = 1;  
            }  
        }  
        color[id] = seq[n];  
        len[id++] = cnt;  

        memset(vis, false, sizeof(vis));  
        for(i = id-1; i &gt;= 1; i--){ /*此处after[i]记录i之后与i颜色相同的方块最多有多少个*/                                       if(vis[i]) continue;  after[i] = 0;  
            int tmp = i;  
            for(j = i-2; j &gt;= 1; j--)  
                if(color[j] == color[tmp]){  
                    after[j] = after[tmp] + len[tmp];  
                    tmp = j;  
                    vis[j--] = true;  
                }  
        }  

        memset(dp, 0, sizeof(dp));  
        for(j = 1; j &lt; id; j++){  //按长度遍历  
            for(l = 1; l+j-1 &lt; id; l++){    
                r = l+j-1;  
                for(k = 0; k &lt;= after[r]; k++){ //k为未来接在r后的方块数  
                    dp[l][r][k] = dp[l][r-1][0]+(len[r]+k)*(len[r]+k);  
                    for(p = r-2; p &gt;= l; p--)  
                        if(color[p] == color[r])  
                            dp[l][r][k] = MAX(dp[l][r][k], dp[l][p][k+len[r]]+dp[p+1][r-1][0]);  
                }  
            }  
        }  
        printf(&quot;Case %d: %d\n&quot;, cas++, dp[1][id-1][0]);  
    }  
    system(&quot;pause&quot;);  
    return 0;  
}
</code></pre>


<!--<a href="http://yoursite.com/2018/04/16/黑书动态规划习题/#disqus_thread" class="article-comment-link">Comments</a>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'undefined'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
<div style="display:none">
<script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script>
</div>






</body>
</html>